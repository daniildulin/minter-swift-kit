// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum MinterBlockField: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case transactions // = 0
  case missed // = 1
  case blockReward // = 2
  case size // = 3
  case proposer // = 4
  case validators // = 5
  case evidence // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .transactions
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .transactions
    case 1: self = .missed
    case 2: self = .blockReward
    case 3: self = .size
    case 4: self = .proposer
    case 5: self = .validators
    case 6: self = .evidence
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .transactions: return 0
    case .missed: return 1
    case .blockReward: return 2
    case .size: return 3
    case .proposer: return 4
    case .validators: return 5
    case .evidence: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MinterBlockField: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MinterBlockField] = [
    .transactions,
    .missed,
    .blockReward,
    .size,
    .proposer,
    .validators,
    .evidence,
  ]
}

#endif  // swift(>=4.2)

public enum MinterSwapFrom: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case optimal // = 0
  case bancor // = 1
  case pool // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .optimal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .optimal
    case 1: self = .bancor
    case 2: self = .pool
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .optimal: return 0
    case .bancor: return 1
    case .pool: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MinterSwapFrom: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MinterSwapFrom] = [
    .optimal,
    .bancor,
    .pool,
  ]
}

#endif  // swift(>=4.2)

public struct MinterCoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var symbol: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterBlocksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fromHeight: UInt64 = 0

  public var toHeight: UInt64 = 0

  public var fields: [MinterBlockField] = []

  public var failedTxs: Bool = false

  public var events: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterBlocksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blocks: [MinterBlockResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCommissionVotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetVersion: UInt64 = 0

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCommissionVotesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var votes: [MinterCommissionVotesResponse.Vote] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Vote {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var price: MinterPriceCommissionResponse {
      get {return _price ?? MinterPriceCommissionResponse()}
      set {_price = newValue}
    }
    /// Returns true if `price` has been explicitly set.
    public var hasPrice: Bool {return self._price != nil}
    /// Clears the value of `price`. Subsequent reads from it will return its default value.
    public mutating func clearPrice() {self._price = nil}

    public var publicKeys: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _price: MinterPriceCommissionResponse? = nil
  }

  public init() {}
}

public struct MinterLimitOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var orderID: UInt64 = 0

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var coinSell: MinterCoin {
    get {return _coinSell ?? MinterCoin()}
    set {_coinSell = newValue}
  }
  /// Returns true if `coinSell` has been explicitly set.
  public var hasCoinSell: Bool {return self._coinSell != nil}
  /// Clears the value of `coinSell`. Subsequent reads from it will return its default value.
  public mutating func clearCoinSell() {self._coinSell = nil}

  public var coinBuy: MinterCoin {
    get {return _coinBuy ?? MinterCoin()}
    set {_coinBuy = newValue}
  }
  /// Returns true if `coinBuy` has been explicitly set.
  public var hasCoinBuy: Bool {return self._coinBuy != nil}
  /// Clears the value of `coinBuy`. Subsequent reads from it will return its default value.
  public mutating func clearCoinBuy() {self._coinBuy = nil}

  public var wantSell: String = String()

  public var wantBuy: String = String()

  public var price: String = String()

  public var owner: String = String()

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coinSell: MinterCoin? = nil
  fileprivate var _coinBuy: MinterCoin? = nil
}

public struct MinterLimitOrdersOfPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sellCoin: UInt64 = 0

  public var buyCoin: UInt64 = 0

  public var limit: Int32 = 0

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterLimitOrdersOfPoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var poolPrice: String = String()

  public var orders: [MinterLimitOrderResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterLimitOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [UInt64] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterLimitOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var orders: [MinterLimitOrderResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterUpdateVotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetVersion: UInt64 = 0

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterUpdateVotesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var votes: [MinterUpdateVotesResponse.Vote] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Vote {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var version: String = String()

    public var publicKeys: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct MinterVersionNetworkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterVersionNetworkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var current: String = String()

  public var versions: [MinterVersionNetworkResponse.Version] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Version {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var height: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct MinterPriceCommissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterPriceCommissionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: MinterCoin {
    get {return _storage._coin ?? MinterCoin()}
    set {_uniqueStorage()._coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return _storage._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {_uniqueStorage()._coin = nil}

  public var payloadByte: String {
    get {return _storage._payloadByte}
    set {_uniqueStorage()._payloadByte = newValue}
  }

  public var send: String {
    get {return _storage._send}
    set {_uniqueStorage()._send = newValue}
  }

  public var buyBancor: String {
    get {return _storage._buyBancor}
    set {_uniqueStorage()._buyBancor = newValue}
  }

  public var sellBancor: String {
    get {return _storage._sellBancor}
    set {_uniqueStorage()._sellBancor = newValue}
  }

  public var sellAllBancor: String {
    get {return _storage._sellAllBancor}
    set {_uniqueStorage()._sellAllBancor = newValue}
  }

  public var buyPoolBase: String {
    get {return _storage._buyPoolBase}
    set {_uniqueStorage()._buyPoolBase = newValue}
  }

  public var buyPoolDelta: String {
    get {return _storage._buyPoolDelta}
    set {_uniqueStorage()._buyPoolDelta = newValue}
  }

  public var sellPoolBase: String {
    get {return _storage._sellPoolBase}
    set {_uniqueStorage()._sellPoolBase = newValue}
  }

  public var sellPoolDelta: String {
    get {return _storage._sellPoolDelta}
    set {_uniqueStorage()._sellPoolDelta = newValue}
  }

  public var sellAllPoolBase: String {
    get {return _storage._sellAllPoolBase}
    set {_uniqueStorage()._sellAllPoolBase = newValue}
  }

  public var sellAllPoolDelta: String {
    get {return _storage._sellAllPoolDelta}
    set {_uniqueStorage()._sellAllPoolDelta = newValue}
  }

  public var createTicker3: String {
    get {return _storage._createTicker3}
    set {_uniqueStorage()._createTicker3 = newValue}
  }

  public var createTicker4: String {
    get {return _storage._createTicker4}
    set {_uniqueStorage()._createTicker4 = newValue}
  }

  public var createTicker5: String {
    get {return _storage._createTicker5}
    set {_uniqueStorage()._createTicker5 = newValue}
  }

  public var createTicker6: String {
    get {return _storage._createTicker6}
    set {_uniqueStorage()._createTicker6 = newValue}
  }

  public var createTicker710: String {
    get {return _storage._createTicker710}
    set {_uniqueStorage()._createTicker710 = newValue}
  }

  public var createCoin: String {
    get {return _storage._createCoin}
    set {_uniqueStorage()._createCoin = newValue}
  }

  public var createToken: String {
    get {return _storage._createToken}
    set {_uniqueStorage()._createToken = newValue}
  }

  public var recreateCoin: String {
    get {return _storage._recreateCoin}
    set {_uniqueStorage()._recreateCoin = newValue}
  }

  public var recreateToken: String {
    get {return _storage._recreateToken}
    set {_uniqueStorage()._recreateToken = newValue}
  }

  public var declareCandidacy: String {
    get {return _storage._declareCandidacy}
    set {_uniqueStorage()._declareCandidacy = newValue}
  }

  public var delegate: String {
    get {return _storage._delegate}
    set {_uniqueStorage()._delegate = newValue}
  }

  public var unbond: String {
    get {return _storage._unbond}
    set {_uniqueStorage()._unbond = newValue}
  }

  public var redeemCheck: String {
    get {return _storage._redeemCheck}
    set {_uniqueStorage()._redeemCheck = newValue}
  }

  public var setCandidateOn: String {
    get {return _storage._setCandidateOn}
    set {_uniqueStorage()._setCandidateOn = newValue}
  }

  public var setCandidateOff: String {
    get {return _storage._setCandidateOff}
    set {_uniqueStorage()._setCandidateOff = newValue}
  }

  public var createMultisig: String {
    get {return _storage._createMultisig}
    set {_uniqueStorage()._createMultisig = newValue}
  }

  public var multisendBase: String {
    get {return _storage._multisendBase}
    set {_uniqueStorage()._multisendBase = newValue}
  }

  public var multisendDelta: String {
    get {return _storage._multisendDelta}
    set {_uniqueStorage()._multisendDelta = newValue}
  }

  public var editCandidate: String {
    get {return _storage._editCandidate}
    set {_uniqueStorage()._editCandidate = newValue}
  }

  public var setHaltBlock: String {
    get {return _storage._setHaltBlock}
    set {_uniqueStorage()._setHaltBlock = newValue}
  }

  public var editTickerOwner: String {
    get {return _storage._editTickerOwner}
    set {_uniqueStorage()._editTickerOwner = newValue}
  }

  public var editMultisig: String {
    get {return _storage._editMultisig}
    set {_uniqueStorage()._editMultisig = newValue}
  }

  public var editCandidatePublicKey: String {
    get {return _storage._editCandidatePublicKey}
    set {_uniqueStorage()._editCandidatePublicKey = newValue}
  }

  public var createSwapPool: String {
    get {return _storage._createSwapPool}
    set {_uniqueStorage()._createSwapPool = newValue}
  }

  public var addLiquidity: String {
    get {return _storage._addLiquidity}
    set {_uniqueStorage()._addLiquidity = newValue}
  }

  public var removeLiquidity: String {
    get {return _storage._removeLiquidity}
    set {_uniqueStorage()._removeLiquidity = newValue}
  }

  public var editCandidateCommission: String {
    get {return _storage._editCandidateCommission}
    set {_uniqueStorage()._editCandidateCommission = newValue}
  }

  public var mintToken: String {
    get {return _storage._mintToken}
    set {_uniqueStorage()._mintToken = newValue}
  }

  public var burnToken: String {
    get {return _storage._burnToken}
    set {_uniqueStorage()._burnToken = newValue}
  }

  public var voteCommission: String {
    get {return _storage._voteCommission}
    set {_uniqueStorage()._voteCommission = newValue}
  }

  public var voteUpdate: String {
    get {return _storage._voteUpdate}
    set {_uniqueStorage()._voteUpdate = newValue}
  }

  public var failedTx: String {
    get {return _storage._failedTx}
    set {_uniqueStorage()._failedTx = newValue}
  }

  public var addLimitOrder: String {
    get {return _storage._addLimitOrder}
    set {_uniqueStorage()._addLimitOrder = newValue}
  }

  public var removeLimitOrder: String {
    get {return _storage._removeLimitOrder}
    set {_uniqueStorage()._removeLimitOrder = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MinterSwapPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin0: UInt64 = 0

  public var coin1: UInt64 = 0

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSwapPoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var price: String = String()

  public var amount0: String = String()

  public var amount1: String = String()

  public var liquidity: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSwapPoolProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin0: UInt64 = 0

  public var coin1: UInt64 = 0

  public var provider: String = String()

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var protocolVersion: MinterNodeInfo.ProtocolVersion {
    get {return _protocolVersion ?? MinterNodeInfo.ProtocolVersion()}
    set {_protocolVersion = newValue}
  }
  /// Returns true if `protocolVersion` has been explicitly set.
  public var hasProtocolVersion: Bool {return self._protocolVersion != nil}
  /// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
  public mutating func clearProtocolVersion() {self._protocolVersion = nil}

  public var id: String = String()

  public var listenAddr: String = String()

  public var network: String = String()

  public var version: String = String()

  public var channels: String = String()

  public var moniker: String = String()

  public var other: MinterNodeInfo.Other {
    get {return _other ?? MinterNodeInfo.Other()}
    set {_other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return self._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {self._other = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ProtocolVersion {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var p2P: UInt64 = 0

    public var block: UInt64 = 0

    public var app: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Other {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var txIndex: String = String()

    public var rpcAddress: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _protocolVersion: MinterNodeInfo.ProtocolVersion? = nil
  fileprivate var _other: MinterNodeInfo.Other? = nil
}

public struct MinterNetInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listening: Bool = false

  public var listeners: [String] = []

  public var countPeers: Int64 = 0

  public var peers: [MinterNetInfoResponse.Peer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Peer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unknown while client is in fast_syncing mode
    public var latestBlockHeight: SwiftProtobuf.Google_Protobuf_UInt64Value {
      get {return _latestBlockHeight ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
      set {_latestBlockHeight = newValue}
    }
    /// Returns true if `latestBlockHeight` has been explicitly set.
    public var hasLatestBlockHeight: Bool {return self._latestBlockHeight != nil}
    /// Clears the value of `latestBlockHeight`. Subsequent reads from it will return its default value.
    public mutating func clearLatestBlockHeight() {self._latestBlockHeight = nil}

    public var nodeInfo: MinterNodeInfo {
      get {return _nodeInfo ?? MinterNodeInfo()}
      set {_nodeInfo = newValue}
    }
    /// Returns true if `nodeInfo` has been explicitly set.
    public var hasNodeInfo: Bool {return self._nodeInfo != nil}
    /// Clears the value of `nodeInfo`. Subsequent reads from it will return its default value.
    public mutating func clearNodeInfo() {self._nodeInfo = nil}

    public var isOutbound: Bool = false

    public var connectionStatus: MinterNetInfoResponse.Peer.ConnectionStatus {
      get {return _connectionStatus ?? MinterNetInfoResponse.Peer.ConnectionStatus()}
      set {_connectionStatus = newValue}
    }
    /// Returns true if `connectionStatus` has been explicitly set.
    public var hasConnectionStatus: Bool {return self._connectionStatus != nil}
    /// Clears the value of `connectionStatus`. Subsequent reads from it will return its default value.
    public mutating func clearConnectionStatus() {self._connectionStatus = nil}

    public var remoteIp: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ConnectionStatus {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var duration: UInt64 {
        get {return _storage._duration}
        set {_uniqueStorage()._duration = newValue}
      }

      public var sendMonitor: MinterNetInfoResponse.Peer.ConnectionStatus.Monitor {
        get {return _storage._sendMonitor ?? MinterNetInfoResponse.Peer.ConnectionStatus.Monitor()}
        set {_uniqueStorage()._sendMonitor = newValue}
      }
      /// Returns true if `sendMonitor` has been explicitly set.
      public var hasSendMonitor: Bool {return _storage._sendMonitor != nil}
      /// Clears the value of `sendMonitor`. Subsequent reads from it will return its default value.
      public mutating func clearSendMonitor() {_uniqueStorage()._sendMonitor = nil}

      public var recvMonitor: MinterNetInfoResponse.Peer.ConnectionStatus.Monitor {
        get {return _storage._recvMonitor ?? MinterNetInfoResponse.Peer.ConnectionStatus.Monitor()}
        set {_uniqueStorage()._recvMonitor = newValue}
      }
      /// Returns true if `recvMonitor` has been explicitly set.
      public var hasRecvMonitor: Bool {return _storage._recvMonitor != nil}
      /// Clears the value of `recvMonitor`. Subsequent reads from it will return its default value.
      public mutating func clearRecvMonitor() {_uniqueStorage()._recvMonitor = nil}

      public var channels: [MinterNetInfoResponse.Peer.ConnectionStatus.Channel] {
        get {return _storage._channels}
        set {_uniqueStorage()._channels = newValue}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Monitor {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var active: Bool = false

        public var start: String = String()

        public var duration: Int64 = 0

        public var idle: Int64 = 0

        public var bytes: Int64 = 0

        public var samples: Int64 = 0

        public var instRate: Int64 = 0

        public var curRate: Int64 = 0

        public var avgRate: Int64 = 0

        public var peakRate: Int64 = 0

        public var bytesRem: Int64 = 0

        public var timeRem: Int64 = 0

        public var progress: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Channel {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: Int64 = 0

        public var sendQueueCapacity: Int64 = 0

        public var sendQueueSize: Int64 = 0

        public var priority: Int64 = 0

        public var recentlySent: Int64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}

    fileprivate var _latestBlockHeight: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    fileprivate var _nodeInfo: MinterNodeInfo? = nil
    fileprivate var _connectionStatus: MinterNetInfoResponse.Peer.ConnectionStatus? = nil
  }

  public init() {}
}

public struct MinterStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var network: String = String()

  public var initialHeight: UInt64 = 0

  public var latestBlockHash: String = String()

  public var latestAppHash: String = String()

  public var latestBlockHeight: UInt64 = 0

  public var latestBlockTime: String = String()

  public var keepLastStates: UInt64 = 0

  public var totalSlashed: String = String()

  public var catchingUp: Bool = false

  public var publicKey: String = String()

  public var nodeID: String = String()

  public var moniker: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterGenesisResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  public var initialHeight: UInt64 {
    get {return _storage._initialHeight}
    set {_uniqueStorage()._initialHeight = newValue}
  }

  public var consensusParams: MinterGenesisResponse.ConsensusParams {
    get {return _storage._consensusParams ?? MinterGenesisResponse.ConsensusParams()}
    set {_uniqueStorage()._consensusParams = newValue}
  }
  /// Returns true if `consensusParams` has been explicitly set.
  public var hasConsensusParams: Bool {return _storage._consensusParams != nil}
  /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
  public mutating func clearConsensusParams() {_uniqueStorage()._consensusParams = nil}

  public var appHash: String {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  public var appState: MinterGenesisResponse.AppState {
    get {return _storage._appState ?? MinterGenesisResponse.AppState()}
    set {_uniqueStorage()._appState = newValue}
  }
  /// Returns true if `appState` has been explicitly set.
  public var hasAppState: Bool {return _storage._appState != nil}
  /// Clears the value of `appState`. Subsequent reads from it will return its default value.
  public mutating func clearAppState() {_uniqueStorage()._appState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ConsensusParams {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var block: MinterGenesisResponse.ConsensusParams.Block {
      get {return _block ?? MinterGenesisResponse.ConsensusParams.Block()}
      set {_block = newValue}
    }
    /// Returns true if `block` has been explicitly set.
    public var hasBlock: Bool {return self._block != nil}
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    public mutating func clearBlock() {self._block = nil}

    public var evidence: MinterGenesisResponse.ConsensusParams.Evidence {
      get {return _evidence ?? MinterGenesisResponse.ConsensusParams.Evidence()}
      set {_evidence = newValue}
    }
    /// Returns true if `evidence` has been explicitly set.
    public var hasEvidence: Bool {return self._evidence != nil}
    /// Clears the value of `evidence`. Subsequent reads from it will return its default value.
    public mutating func clearEvidence() {self._evidence = nil}

    public var validator: MinterGenesisResponse.ConsensusParams.Validator {
      get {return _validator ?? MinterGenesisResponse.ConsensusParams.Validator()}
      set {_validator = newValue}
    }
    /// Returns true if `validator` has been explicitly set.
    public var hasValidator: Bool {return self._validator != nil}
    /// Clears the value of `validator`. Subsequent reads from it will return its default value.
    public mutating func clearValidator() {self._validator = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Block {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var maxBytes: Int64 = 0

      public var maxGas: Int64 = 0

      public var timeIotaMs: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Evidence {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var maxAgeNumBlocks: Int64 = 0

      public var maxAgeDuration: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Validator {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var pubKeyTypes: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _block: MinterGenesisResponse.ConsensusParams.Block? = nil
    fileprivate var _evidence: MinterGenesisResponse.ConsensusParams.Evidence? = nil
    fileprivate var _validator: MinterGenesisResponse.ConsensusParams.Validator? = nil
  }

  public struct AppState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var version: String = String()

    public var note: String = String()

    public var validators: [MinterGenesisResponse.AppState.Validators] = []

    public var candidates: [MinterGenesisResponse.AppState.Candidate] = []

    public var coins: [MinterGenesisResponse.AppState.Coin] = []

    public var frozenFunds: [MinterGenesisResponse.AppState.FrozenFund] = []

    public var blockListCandidates: [String] = []

    public var waitlist: [MinterGenesisResponse.AppState.Waitlist] = []

    public var accounts: [MinterGenesisResponse.AppState.Account] = []

    public var haltBlocks: [MinterGenesisResponse.AppState.HaltBlock] = []

    public var pools: [MinterGenesisResponse.AppState.Pool] = []

    public var commission: MinterGenesisResponse.AppState.Commission {
      get {return _commission ?? MinterGenesisResponse.AppState.Commission()}
      set {_commission = newValue}
    }
    /// Returns true if `commission` has been explicitly set.
    public var hasCommission: Bool {return self._commission != nil}
    /// Clears the value of `commission`. Subsequent reads from it will return its default value.
    public mutating func clearCommission() {self._commission = nil}

    public var commissionVotes: [MinterGenesisResponse.AppState.CommissionVote] = []

    public var usedChecks: [String] = []

    public var maxGas: UInt64 = 0

    public var totalSlashed: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Validators {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var totalBipStake: String = String()

      public var publicKey: String = String()

      public var accumReward: String = String()

      public var absentTimes: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Candidate {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: UInt64 = 0

      public var rewardAddress: String = String()

      public var ownerAddress: String = String()

      public var controlAddress: String = String()

      public var totalBipStake: String = String()

      public var publicKey: String = String()

      public var commission: UInt64 = 0

      public var stakes: [MinterGenesisResponse.AppState.Candidate.Stake] = []

      public var updates: [MinterGenesisResponse.AppState.Candidate.Stake] = []

      public var status: Int64 = 0

      public var jailedUntil: Int64 = 0

      public var lastEditCommissionHeight: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Stake {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var owner: String = String()

        public var coin: UInt64 = 0

        public var value: String = String()

        public var bipValue: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public struct Coin {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: UInt64 = 0

      public var name: String = String()

      public var symbol: String = String()

      public var volume: String = String()

      public var crr: UInt64 = 0

      public var reserve: String = String()

      public var maxSupply: String = String()

      public var version: UInt64 = 0

      public var ownerAddress: SwiftProtobuf.Google_Protobuf_StringValue {
        get {return _ownerAddress ?? SwiftProtobuf.Google_Protobuf_StringValue()}
        set {_ownerAddress = newValue}
      }
      /// Returns true if `ownerAddress` has been explicitly set.
      public var hasOwnerAddress: Bool {return self._ownerAddress != nil}
      /// Clears the value of `ownerAddress`. Subsequent reads from it will return its default value.
      public mutating func clearOwnerAddress() {self._ownerAddress = nil}

      public var mintable: Bool = false

      public var burnable: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _ownerAddress: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    }

    public struct FrozenFund {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var height: UInt64 = 0

      public var address: String = String()

      public var candidateKey: SwiftProtobuf.Google_Protobuf_StringValue {
        get {return _candidateKey ?? SwiftProtobuf.Google_Protobuf_StringValue()}
        set {_candidateKey = newValue}
      }
      /// Returns true if `candidateKey` has been explicitly set.
      public var hasCandidateKey: Bool {return self._candidateKey != nil}
      /// Clears the value of `candidateKey`. Subsequent reads from it will return its default value.
      public mutating func clearCandidateKey() {self._candidateKey = nil}

      public var candidateID: UInt64 = 0

      public var coin: UInt64 = 0

      public var value: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _candidateKey: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    }

    public struct Waitlist {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var candidateID: UInt64 = 0

      public var owner: String = String()

      public var coin: UInt64 = 0

      public var value: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Account {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var address: String = String()

      public var balance: [MinterGenesisResponse.AppState.Account.Balance] = []

      public var nonce: UInt64 = 0

      public var multisigData: MinterGenesisResponse.AppState.Account.MultisigData {
        get {return _multisigData ?? MinterGenesisResponse.AppState.Account.MultisigData()}
        set {_multisigData = newValue}
      }
      /// Returns true if `multisigData` has been explicitly set.
      public var hasMultisigData: Bool {return self._multisigData != nil}
      /// Clears the value of `multisigData`. Subsequent reads from it will return its default value.
      public mutating func clearMultisigData() {self._multisigData = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Balance {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var coin: UInt64 = 0

        public var value: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct MultisigData {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var threshold: UInt64 = 0

        public var weights: [UInt64] = []

        public var addresses: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _multisigData: MinterGenesisResponse.AppState.Account.MultisigData? = nil
    }

    public struct HaltBlock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var height: UInt64 = 0

      public var candidateKey: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Pool {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var coin0: UInt64 = 0

      public var coin1: UInt64 = 0

      public var reserve0: String = String()

      public var reserve1: String = String()

      public var id: UInt64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Commission {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var coin: UInt64 {
        get {return _storage._coin}
        set {_uniqueStorage()._coin = newValue}
      }

      public var payloadByte: String {
        get {return _storage._payloadByte}
        set {_uniqueStorage()._payloadByte = newValue}
      }

      public var send: String {
        get {return _storage._send}
        set {_uniqueStorage()._send = newValue}
      }

      public var buyBancor: String {
        get {return _storage._buyBancor}
        set {_uniqueStorage()._buyBancor = newValue}
      }

      public var sellBancor: String {
        get {return _storage._sellBancor}
        set {_uniqueStorage()._sellBancor = newValue}
      }

      public var sellAllBancor: String {
        get {return _storage._sellAllBancor}
        set {_uniqueStorage()._sellAllBancor = newValue}
      }

      public var buyPoolBase: String {
        get {return _storage._buyPoolBase}
        set {_uniqueStorage()._buyPoolBase = newValue}
      }

      public var buyPoolDelta: String {
        get {return _storage._buyPoolDelta}
        set {_uniqueStorage()._buyPoolDelta = newValue}
      }

      public var sellPoolBase: String {
        get {return _storage._sellPoolBase}
        set {_uniqueStorage()._sellPoolBase = newValue}
      }

      public var sellPoolDelta: String {
        get {return _storage._sellPoolDelta}
        set {_uniqueStorage()._sellPoolDelta = newValue}
      }

      public var sellAllPoolBase: String {
        get {return _storage._sellAllPoolBase}
        set {_uniqueStorage()._sellAllPoolBase = newValue}
      }

      public var sellAllPoolDelta: String {
        get {return _storage._sellAllPoolDelta}
        set {_uniqueStorage()._sellAllPoolDelta = newValue}
      }

      public var createTicker3: String {
        get {return _storage._createTicker3}
        set {_uniqueStorage()._createTicker3 = newValue}
      }

      public var createTicker4: String {
        get {return _storage._createTicker4}
        set {_uniqueStorage()._createTicker4 = newValue}
      }

      public var createTicker5: String {
        get {return _storage._createTicker5}
        set {_uniqueStorage()._createTicker5 = newValue}
      }

      public var createTicker6: String {
        get {return _storage._createTicker6}
        set {_uniqueStorage()._createTicker6 = newValue}
      }

      public var createTicker710: String {
        get {return _storage._createTicker710}
        set {_uniqueStorage()._createTicker710 = newValue}
      }

      public var createCoin: String {
        get {return _storage._createCoin}
        set {_uniqueStorage()._createCoin = newValue}
      }

      public var createToken: String {
        get {return _storage._createToken}
        set {_uniqueStorage()._createToken = newValue}
      }

      public var recreateCoin: String {
        get {return _storage._recreateCoin}
        set {_uniqueStorage()._recreateCoin = newValue}
      }

      public var recreateToken: String {
        get {return _storage._recreateToken}
        set {_uniqueStorage()._recreateToken = newValue}
      }

      public var declareCandidacy: String {
        get {return _storage._declareCandidacy}
        set {_uniqueStorage()._declareCandidacy = newValue}
      }

      public var delegate: String {
        get {return _storage._delegate}
        set {_uniqueStorage()._delegate = newValue}
      }

      public var unbond: String {
        get {return _storage._unbond}
        set {_uniqueStorage()._unbond = newValue}
      }

      public var redeemCheck: String {
        get {return _storage._redeemCheck}
        set {_uniqueStorage()._redeemCheck = newValue}
      }

      public var setCandidateOn: String {
        get {return _storage._setCandidateOn}
        set {_uniqueStorage()._setCandidateOn = newValue}
      }

      public var setCandidateOff: String {
        get {return _storage._setCandidateOff}
        set {_uniqueStorage()._setCandidateOff = newValue}
      }

      public var createMultisig: String {
        get {return _storage._createMultisig}
        set {_uniqueStorage()._createMultisig = newValue}
      }

      public var multisendBase: String {
        get {return _storage._multisendBase}
        set {_uniqueStorage()._multisendBase = newValue}
      }

      public var multisendDelta: String {
        get {return _storage._multisendDelta}
        set {_uniqueStorage()._multisendDelta = newValue}
      }

      public var editCandidate: String {
        get {return _storage._editCandidate}
        set {_uniqueStorage()._editCandidate = newValue}
      }

      public var setHaltBlock: String {
        get {return _storage._setHaltBlock}
        set {_uniqueStorage()._setHaltBlock = newValue}
      }

      public var editTickerOwner: String {
        get {return _storage._editTickerOwner}
        set {_uniqueStorage()._editTickerOwner = newValue}
      }

      public var editMultisig: String {
        get {return _storage._editMultisig}
        set {_uniqueStorage()._editMultisig = newValue}
      }

      public var editCandidatePublicKey: String {
        get {return _storage._editCandidatePublicKey}
        set {_uniqueStorage()._editCandidatePublicKey = newValue}
      }

      public var createSwapPool: String {
        get {return _storage._createSwapPool}
        set {_uniqueStorage()._createSwapPool = newValue}
      }

      public var addLiquidity: String {
        get {return _storage._addLiquidity}
        set {_uniqueStorage()._addLiquidity = newValue}
      }

      public var removeLiquidity: String {
        get {return _storage._removeLiquidity}
        set {_uniqueStorage()._removeLiquidity = newValue}
      }

      public var editCandidateCommission: String {
        get {return _storage._editCandidateCommission}
        set {_uniqueStorage()._editCandidateCommission = newValue}
      }

      public var mintToken: String {
        get {return _storage._mintToken}
        set {_uniqueStorage()._mintToken = newValue}
      }

      public var burnToken: String {
        get {return _storage._burnToken}
        set {_uniqueStorage()._burnToken = newValue}
      }

      public var voteCommission: String {
        get {return _storage._voteCommission}
        set {_uniqueStorage()._voteCommission = newValue}
      }

      public var voteUpdate: String {
        get {return _storage._voteUpdate}
        set {_uniqueStorage()._voteUpdate = newValue}
      }

      public var failedTx: String {
        get {return _storage._failedTx}
        set {_uniqueStorage()._failedTx = newValue}
      }

      public var addLimitOrder: String {
        get {return _storage._addLimitOrder}
        set {_uniqueStorage()._addLimitOrder = newValue}
      }

      public var removeLimitOrder: String {
        get {return _storage._removeLimitOrder}
        set {_uniqueStorage()._removeLimitOrder = newValue}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public struct CommissionVote {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var height: UInt64 = 0

      public var votes: [String] = []

      public var commission: MinterGenesisResponse.AppState.Commission {
        get {return _commission ?? MinterGenesisResponse.AppState.Commission()}
        set {_commission = newValue}
      }
      /// Returns true if `commission` has been explicitly set.
      public var hasCommission: Bool {return self._commission != nil}
      /// Clears the value of `commission`. Subsequent reads from it will return its default value.
      public mutating func clearCommission() {self._commission = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _commission: MinterGenesisResponse.AppState.Commission? = nil
    }

    public init() {}

    fileprivate var _commission: MinterGenesisResponse.AppState.Commission? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MinterMinGasPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var minGasPrice: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var fields: [MinterBlockField] = []

  public var failedTxs: Bool = false

  public var events: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var height: UInt64 = 0

  public var time: String = String()

  public var transactionCount: UInt64 = 0

  public var transactions: [MinterTransactionResponse] = []

  public var blockReward: String = String()

  public var size: UInt64 = 0

  public var proposer: String = String()

  public var validators: [MinterBlockResponse.Validator] = []

  public var evidence: MinterBlockResponse.Evidence {
    get {return _evidence ?? MinterBlockResponse.Evidence()}
    set {_evidence = newValue}
  }
  /// Returns true if `evidence` has been explicitly set.
  public var hasEvidence: Bool {return self._evidence != nil}
  /// Clears the value of `evidence`. Subsequent reads from it will return its default value.
  public mutating func clearEvidence() {self._evidence = nil}

  public var missed: [String] = []

  public var events: [SwiftProtobuf.Google_Protobuf_Any] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Validator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var publicKey: String = String()

    public var signed: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Evidence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var evidence: [SwiftProtobuf.Google_Protobuf_Struct] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _evidence: MinterBlockResponse.Evidence? = nil
}

public struct MinterMaxGasPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterMaxGasPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxGasPrice: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var height: UInt64 = 0

  public var delegated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterAddressBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var value: String = String()

  public var bipValue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterAddressDelegatedBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var value: String = String()

  public var bipValue: String = String()

  public var delegateBipValue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balance: [MinterAddressBalance] = []

  public var delegated: [MinterAddressDelegatedBalance] = []

  public var total: [MinterAddressBalance] = []

  public var transactionCount: UInt64 = 0

  public var bipValue: String = String()

  public var multisig: MinterMultisig {
    get {return _multisig ?? MinterMultisig()}
    set {_multisig = newValue}
  }
  /// Returns true if `multisig` has been explicitly set.
  public var hasMultisig: Bool {return self._multisig != nil}
  /// Clears the value of `multisig`. Subsequent reads from it will return its default value.
  public mutating func clearMultisig() {self._multisig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _multisig: MinterMultisig? = nil
}

public struct MinterMultisig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threshold: UInt64 = 0

  public var weights: [UInt64] = []

  public var addresses: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterAddressesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var addresses: [String] = []

  public var height: UInt64 = 0

  public var delegated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterAddressesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var addresses: Dictionary<String,MinterAddressesResponse.Result> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var balance: [MinterAddressBalance] = []

    /// Filled in when request delegated
    public var delegated: [MinterAddressDelegatedBalance] = []

    /// Sum of balance and delegated by coins. Filled in when request delegated
    public var total: [MinterAddressBalance] = []

    public var transactionCount: UInt64 = 0

    public var bipValue: String = String()

    public var multisig: MinterMultisig {
      get {return _multisig ?? MinterMultisig()}
      set {_multisig = newValue}
    }
    /// Returns true if `multisig` has been explicitly set.
    public var hasMultisig: Bool {return self._multisig != nil}
    /// Clears the value of `multisig`. Subsequent reads from it will return its default value.
    public mutating func clearMultisig() {self._multisig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _multisig: MinterMultisig? = nil
  }

  public init() {}
}

public struct MinterCandidateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public key of a candidate
  public var publicKey: String = String()

  /// Blockchain state height for the current request. Optional, the last default state of the node is used
  public var height: UInt64 = 0

  /// Do not display a list of steaks. Note: used_slots, uniq_users, min_stake will be filled
  public var notShowStakes: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCandidateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  /// Address where validators rewards go to.
  public var rewardAddress: String = String()

  /// Address that allows one to start the candidate by sending the SetCandidateOnline transaction or stop it by sending the SetCandidateOffline transaction. It also enables the owner to edit the node by sending EditCandidate.
  public var ownerAddress: String = String()

  /// Address that allows one to start the candidate by sending the SetCandidateOnline transaction or stop it by sending the SetCandidateOffline transaction.
  public var controlAddress: String = String()

  /// Total stake of a candidate
  public var totalStake: String = String()

  /// Public key of a candidate
  public var publicKey: String = String()

  /// Commission (from 0 to 100) from rewards which delegators will pay to validator
  public var commission: UInt64 = 0

  /// Number of occupied steak slots. Note: filled in when request includes_stakes
  public var usedSlots: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _usedSlots ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_usedSlots = newValue}
  }
  /// Returns true if `usedSlots` has been explicitly set.
  public var hasUsedSlots: Bool {return self._usedSlots != nil}
  /// Clears the value of `usedSlots`. Subsequent reads from it will return its default value.
  public mutating func clearUsedSlots() {self._usedSlots = nil}

  /// Number of unique wallets in steaks. Note: filled in when request includes_stakes
  public var uniqUsers: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _uniqUsers ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqUsers = newValue}
  }
  /// Returns true if `uniqUsers` has been explicitly set.
  public var hasUniqUsers: Bool {return self._uniqUsers != nil}
  /// Clears the value of `uniqUsers`. Subsequent reads from it will return its default value.
  public mutating func clearUniqUsers() {self._uniqUsers = nil}

  /// Smallest steak size. Note: filled in when request includes_stakes
  public var minStake: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _minStake ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_minStake = newValue}
  }
  /// Returns true if `minStake` has been explicitly set.
  public var hasMinStake: Bool {return self._minStake != nil}
  /// Clears the value of `minStake`. Subsequent reads from it will return its default value.
  public mutating func clearMinStake() {self._minStake = nil}

  /// List of stakes. Note: filled in when request includes_stakes
  public var stakes: [MinterCandidateResponse.Stake] = []

  /// Candidate status. Available values: offline = 1, online = 2
  public var status: UInt64 = 0

  /// Is a validator at the current height
  public var validator: Bool = false

  public var jailedUntil: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Stake {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var owner: String = String()

    public var coin: MinterCoin {
      get {return _coin ?? MinterCoin()}
      set {_coin = newValue}
    }
    /// Returns true if `coin` has been explicitly set.
    public var hasCoin: Bool {return self._coin != nil}
    /// Clears the value of `coin`. Subsequent reads from it will return its default value.
    public mutating func clearCoin() {self._coin = nil}

    public var value: String = String()

    public var bipValue: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _coin: MinterCoin? = nil
  }

  public init() {}

  fileprivate var _usedSlots: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
  fileprivate var _uniqUsers: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
  fileprivate var _minStake: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

public struct MinterCandidatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Blockchain state height for the current request. Optional, the last default state of the node is used
  public var height: UInt64 = 0

  /// Calculate field values used_slots, uniq_users, min_stake
  public var includeStakes: Bool = false

  /// Do not display the list of stakes, the include_stakes flag is also required to display. Note: used_slots, uniq_users, min_stake will still be filled if include_stakes flag is used
  public var notShowStakes: Bool = false

  public var status: MinterCandidatesRequest.CandidateStatus = .all

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CandidateStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case off // = 1
    case on // = 2
    case validator // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .off
      case 2: self = .on
      case 3: self = .validator
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .off: return 1
      case .on: return 2
      case .validator: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension MinterCandidatesRequest.CandidateStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MinterCandidatesRequest.CandidateStatus] = [
    .all,
    .off,
    .on,
    .validator,
  ]
}

#endif  // swift(>=4.2)

public struct MinterCandidatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var candidates: [MinterCandidateResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCoinIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var id: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCoinInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var symbol: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCoinInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var symbol: String = String()

  public var volume: String = String()

  public var crr: UInt64 = 0

  public var reserveBalance: String = String()

  public var maxSupply: String = String()

  public var ownerAddress: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _ownerAddress ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_ownerAddress = newValue}
  }
  /// Returns true if `ownerAddress` has been explicitly set.
  public var hasOwnerAddress: Bool {return self._ownerAddress != nil}
  /// Clears the value of `ownerAddress`. Subsequent reads from it will return its default value.
  public mutating func clearOwnerAddress() {self._ownerAddress = nil}

  public var mintable: Bool = false

  public var burnable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ownerAddress: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

public struct MinterSendTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: UInt64 = 0

  public var log: String = String()

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSendTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var rawTx: String {
    get {return _storage._rawTx}
    set {_uniqueStorage()._rawTx = newValue}
  }

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var index: UInt64 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  public var from: String {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  public var nonce: UInt64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var gas: UInt64 {
    get {return _storage._gas}
    set {_uniqueStorage()._gas = newValue}
  }

  public var gasPrice: UInt64 {
    get {return _storage._gasPrice}
    set {_uniqueStorage()._gasPrice = newValue}
  }

  public var gasCoin: MinterCoin {
    get {return _storage._gasCoin ?? MinterCoin()}
    set {_uniqueStorage()._gasCoin = newValue}
  }
  /// Returns true if `gasCoin` has been explicitly set.
  public var hasGasCoin: Bool {return _storage._gasCoin != nil}
  /// Clears the value of `gasCoin`. Subsequent reads from it will return its default value.
  public mutating func clearGasCoin() {_uniqueStorage()._gasCoin = nil}

  public var typeHex: String {
    get {return _storage._typeHex}
    set {_uniqueStorage()._typeHex = newValue}
  }

  ///    string type_name = 18;
  public var type: UInt64 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var serviceData: Data {
    get {return _storage._serviceData}
    set {_uniqueStorage()._serviceData = newValue}
  }

  public var tags: Dictionary<String,String> {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var code: UInt64 {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var log: String {
    get {return _storage._log}
    set {_uniqueStorage()._log = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ___ // = 0
    case send // = 1
    case sellCoin // = 2
    case sellAllCoin // = 3
    case buyCoin // = 4
    case createCoin // = 5
    case declareCandidacy // = 6
    case delegate // = 7
    case unbond // = 8
    case redeemCheck // = 9
    case setCandidateOnline // = 10
    case setCandidateOffline // = 11
    case createMultisig // = 12
    case multisend // = 13
    case editCandidate // = 14
    case setHaltBlock // = 15
    case recreateCoin // = 16
    case editCoinOwner // = 17
    case editMultisig // = 18
    case priceVote // = 19
    case editCandidatePublicKey // = 20
    case addLiquidity // = 21
    case removeLiquidity // = 22
    case sellSwapPool // = 23
    case buySwapPool // = 24
    case sellAllSwapPool // = 25
    case editCommissionCandidate // = 26
    case moveStake // = 27
    case mintToken // = 28
    case burnToken // = 29
    case createToken // = 30
    case recreateToken // = 31
    case voteCommission // = 32
    case voteUpdate // = 33
    case createSwapPool // = 34
    case addLimitOrder // = 35
    case removeLimitOrder // = 36
    case UNRECOGNIZED(Int)

    public init() {
      self = .___
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .___
      case 1: self = .send
      case 2: self = .sellCoin
      case 3: self = .sellAllCoin
      case 4: self = .buyCoin
      case 5: self = .createCoin
      case 6: self = .declareCandidacy
      case 7: self = .delegate
      case 8: self = .unbond
      case 9: self = .redeemCheck
      case 10: self = .setCandidateOnline
      case 11: self = .setCandidateOffline
      case 12: self = .createMultisig
      case 13: self = .multisend
      case 14: self = .editCandidate
      case 15: self = .setHaltBlock
      case 16: self = .recreateCoin
      case 17: self = .editCoinOwner
      case 18: self = .editMultisig
      case 19: self = .priceVote
      case 20: self = .editCandidatePublicKey
      case 21: self = .addLiquidity
      case 22: self = .removeLiquidity
      case 23: self = .sellSwapPool
      case 24: self = .buySwapPool
      case 25: self = .sellAllSwapPool
      case 26: self = .editCommissionCandidate
      case 27: self = .moveStake
      case 28: self = .mintToken
      case 29: self = .burnToken
      case 30: self = .createToken
      case 31: self = .recreateToken
      case 32: self = .voteCommission
      case 33: self = .voteUpdate
      case 34: self = .createSwapPool
      case 35: self = .addLimitOrder
      case 36: self = .removeLimitOrder
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .___: return 0
      case .send: return 1
      case .sellCoin: return 2
      case .sellAllCoin: return 3
      case .buyCoin: return 4
      case .createCoin: return 5
      case .declareCandidacy: return 6
      case .delegate: return 7
      case .unbond: return 8
      case .redeemCheck: return 9
      case .setCandidateOnline: return 10
      case .setCandidateOffline: return 11
      case .createMultisig: return 12
      case .multisend: return 13
      case .editCandidate: return 14
      case .setHaltBlock: return 15
      case .recreateCoin: return 16
      case .editCoinOwner: return 17
      case .editMultisig: return 18
      case .priceVote: return 19
      case .editCandidatePublicKey: return 20
      case .addLiquidity: return 21
      case .removeLiquidity: return 22
      case .sellSwapPool: return 23
      case .buySwapPool: return 24
      case .sellAllSwapPool: return 25
      case .editCommissionCandidate: return 26
      case .moveStake: return 27
      case .mintToken: return 28
      case .burnToken: return 29
      case .createToken: return 30
      case .recreateToken: return 31
      case .voteCommission: return 32
      case .voteUpdate: return 33
      case .createSwapPool: return 34
      case .addLimitOrder: return 35
      case .removeLimitOrder: return 36
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension MinterTransactionResponse.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MinterTransactionResponse.TypeEnum] = [
    .___,
    .send,
    .sellCoin,
    .sellAllCoin,
    .buyCoin,
    .createCoin,
    .declareCandidacy,
    .delegate,
    .unbond,
    .redeemCheck,
    .setCandidateOnline,
    .setCandidateOffline,
    .createMultisig,
    .multisend,
    .editCandidate,
    .setHaltBlock,
    .recreateCoin,
    .editCoinOwner,
    .editMultisig,
    .priceVote,
    .editCandidatePublicKey,
    .addLiquidity,
    .removeLiquidity,
    .sellSwapPool,
    .buySwapPool,
    .sellAllSwapPool,
    .editCommissionCandidate,
    .moveStake,
    .mintToken,
    .burnToken,
    .createToken,
    .recreateToken,
    .voteCommission,
    .voteUpdate,
    .createSwapPool,
    .addLimitOrder,
    .removeLimitOrder,
  ]
}

#endif  // swift(>=4.2)

public struct MinterTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterTransactionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactions: [MinterTransactionResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var page: Int32 = 0

  public var perPage: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEstimateCoinBuyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var buy: MinterEstimateCoinBuyRequest.OneOf_Buy? = nil

  public var coinIDToBuy: UInt64 {
    get {
      if case .coinIDToBuy(let v)? = buy {return v}
      return 0
    }
    set {buy = .coinIDToBuy(newValue)}
  }

  public var coinToBuy: String {
    get {
      if case .coinToBuy(let v)? = buy {return v}
      return String()
    }
    set {buy = .coinToBuy(newValue)}
  }

  public var sell: MinterEstimateCoinBuyRequest.OneOf_Sell? = nil

  public var coinIDToSell: UInt64 {
    get {
      if case .coinIDToSell(let v)? = sell {return v}
      return 0
    }
    set {sell = .coinIDToSell(newValue)}
  }

  public var coinToSell: String {
    get {
      if case .coinToSell(let v)? = sell {return v}
      return String()
    }
    set {sell = .coinToSell(newValue)}
  }

  public var valueToBuy: String = String()

  public var height: UInt64 = 0

  public var commission: MinterEstimateCoinBuyRequest.OneOf_Commission? = nil

  public var coinIDCommission: UInt64 {
    get {
      if case .coinIDCommission(let v)? = commission {return v}
      return 0
    }
    set {commission = .coinIDCommission(newValue)}
  }

  public var coinCommission: String {
    get {
      if case .coinCommission(let v)? = commission {return v}
      return String()
    }
    set {commission = .coinCommission(newValue)}
  }

  public var swapFrom: MinterSwapFrom = .optimal

  public var route: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Buy: Equatable {
    case coinIDToBuy(UInt64)
    case coinToBuy(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinBuyRequest.OneOf_Buy, rhs: MinterEstimateCoinBuyRequest.OneOf_Buy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDToBuy, .coinIDToBuy): return {
        guard case .coinIDToBuy(let l) = lhs, case .coinIDToBuy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinToBuy, .coinToBuy): return {
        guard case .coinToBuy(let l) = lhs, case .coinToBuy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_Sell: Equatable {
    case coinIDToSell(UInt64)
    case coinToSell(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinBuyRequest.OneOf_Sell, rhs: MinterEstimateCoinBuyRequest.OneOf_Sell) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDToSell, .coinIDToSell): return {
        guard case .coinIDToSell(let l) = lhs, case .coinIDToSell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinToSell, .coinToSell): return {
        guard case .coinToSell(let l) = lhs, case .coinToSell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_Commission: Equatable {
    case coinIDCommission(UInt64)
    case coinCommission(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinBuyRequest.OneOf_Commission, rhs: MinterEstimateCoinBuyRequest.OneOf_Commission) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDCommission, .coinIDCommission): return {
        guard case .coinIDCommission(let l) = lhs, case .coinIDCommission(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinCommission, .coinCommission): return {
        guard case .coinCommission(let l) = lhs, case .coinCommission(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct MinterEstimateCoinBuyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var willPay: String = String()

  public var commission: String = String()

  public var swapFrom: MinterSwapFrom = .optimal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEstimateCoinSellRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var buy: MinterEstimateCoinSellRequest.OneOf_Buy? = nil

  public var coinIDToBuy: UInt64 {
    get {
      if case .coinIDToBuy(let v)? = buy {return v}
      return 0
    }
    set {buy = .coinIDToBuy(newValue)}
  }

  public var coinToBuy: String {
    get {
      if case .coinToBuy(let v)? = buy {return v}
      return String()
    }
    set {buy = .coinToBuy(newValue)}
  }

  public var sell: MinterEstimateCoinSellRequest.OneOf_Sell? = nil

  public var coinIDToSell: UInt64 {
    get {
      if case .coinIDToSell(let v)? = sell {return v}
      return 0
    }
    set {sell = .coinIDToSell(newValue)}
  }

  public var coinToSell: String {
    get {
      if case .coinToSell(let v)? = sell {return v}
      return String()
    }
    set {sell = .coinToSell(newValue)}
  }

  public var valueToSell: String = String()

  public var height: UInt64 = 0

  public var commission: MinterEstimateCoinSellRequest.OneOf_Commission? = nil

  public var coinIDCommission: UInt64 {
    get {
      if case .coinIDCommission(let v)? = commission {return v}
      return 0
    }
    set {commission = .coinIDCommission(newValue)}
  }

  public var coinCommission: String {
    get {
      if case .coinCommission(let v)? = commission {return v}
      return String()
    }
    set {commission = .coinCommission(newValue)}
  }

  public var swapFrom: MinterSwapFrom = .optimal

  public var route: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Buy: Equatable {
    case coinIDToBuy(UInt64)
    case coinToBuy(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinSellRequest.OneOf_Buy, rhs: MinterEstimateCoinSellRequest.OneOf_Buy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDToBuy, .coinIDToBuy): return {
        guard case .coinIDToBuy(let l) = lhs, case .coinIDToBuy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinToBuy, .coinToBuy): return {
        guard case .coinToBuy(let l) = lhs, case .coinToBuy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_Sell: Equatable {
    case coinIDToSell(UInt64)
    case coinToSell(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinSellRequest.OneOf_Sell, rhs: MinterEstimateCoinSellRequest.OneOf_Sell) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDToSell, .coinIDToSell): return {
        guard case .coinIDToSell(let l) = lhs, case .coinIDToSell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinToSell, .coinToSell): return {
        guard case .coinToSell(let l) = lhs, case .coinToSell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_Commission: Equatable {
    case coinIDCommission(UInt64)
    case coinCommission(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinSellRequest.OneOf_Commission, rhs: MinterEstimateCoinSellRequest.OneOf_Commission) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDCommission, .coinIDCommission): return {
        guard case .coinIDCommission(let l) = lhs, case .coinIDCommission(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinCommission, .coinCommission): return {
        guard case .coinCommission(let l) = lhs, case .coinCommission(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct MinterEstimateCoinSellResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var willGet: String = String()

  public var commission: String = String()

  public var swapFrom: MinterSwapFrom = .optimal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEstimateCoinSellAllRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var buy: MinterEstimateCoinSellAllRequest.OneOf_Buy? = nil

  public var coinIDToBuy: UInt64 {
    get {
      if case .coinIDToBuy(let v)? = buy {return v}
      return 0
    }
    set {buy = .coinIDToBuy(newValue)}
  }

  public var coinToBuy: String {
    get {
      if case .coinToBuy(let v)? = buy {return v}
      return String()
    }
    set {buy = .coinToBuy(newValue)}
  }

  public var sell: MinterEstimateCoinSellAllRequest.OneOf_Sell? = nil

  public var coinIDToSell: UInt64 {
    get {
      if case .coinIDToSell(let v)? = sell {return v}
      return 0
    }
    set {sell = .coinIDToSell(newValue)}
  }

  public var coinToSell: String {
    get {
      if case .coinToSell(let v)? = sell {return v}
      return String()
    }
    set {sell = .coinToSell(newValue)}
  }

  public var valueToSell: String = String()

  public var gasPrice: UInt64 = 0

  public var height: UInt64 = 0

  public var swapFrom: MinterSwapFrom = .optimal

  public var route: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Buy: Equatable {
    case coinIDToBuy(UInt64)
    case coinToBuy(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinSellAllRequest.OneOf_Buy, rhs: MinterEstimateCoinSellAllRequest.OneOf_Buy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDToBuy, .coinIDToBuy): return {
        guard case .coinIDToBuy(let l) = lhs, case .coinIDToBuy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinToBuy, .coinToBuy): return {
        guard case .coinToBuy(let l) = lhs, case .coinToBuy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_Sell: Equatable {
    case coinIDToSell(UInt64)
    case coinToSell(String)

  #if !swift(>=4.1)
    public static func ==(lhs: MinterEstimateCoinSellAllRequest.OneOf_Sell, rhs: MinterEstimateCoinSellAllRequest.OneOf_Sell) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.coinIDToSell, .coinIDToSell): return {
        guard case .coinIDToSell(let l) = lhs, case .coinIDToSell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coinToSell, .coinToSell): return {
        guard case .coinToSell(let l) = lhs, case .coinToSell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct MinterEstimateCoinSellAllResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var willGet: String = String()

  public var swapFrom: MinterSwapFrom = .optimal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEstimateTxCommissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: String = String()

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEstimateTxCommissionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commission: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  /// Array of public keys of validators and wallet addresses of delegators for filtering
  public var search: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [SwiftProtobuf.Google_Protobuf_Struct] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterMissedBlocksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: String = String()

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterMissedBlocksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var missedBlocks: String = String()

  public var missedBlocksCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterUnconfirmedTxsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionCount: UInt64 = 0

  public var totalTransactions: UInt64 = 0

  public var totalBytes: UInt64 = 0

  public var transactions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterUnconfirmedTxsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limit: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterValidatorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterValidatorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validators: [MinterValidatorsResponse.Result] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var publicKey: String = String()

    public var votingPower: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct MinterSubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSubscribeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var data: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var events: [MinterSubscribeResponse.Event] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Event {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var events: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct MinterHaltsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterHaltsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKeys: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterFrozenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var coinID: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _coinID ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_coinID = newValue}
  }
  /// Returns true if `coinID` has been explicitly set.
  public var hasCoinID: Bool {return self._coinID != nil}
  /// Clears the value of `coinID`. Subsequent reads from it will return its default value.
  public mutating func clearCoinID() {self._coinID = nil}

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coinID: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
}

public struct MinterFrozenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var frozen: [MinterFrozenResponse.Frozen] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Frozen {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var height: UInt64 = 0

    public var address: String = String()

    public var candidateKey: String = String()

    public var coin: MinterCoin {
      get {return _coin ?? MinterCoin()}
      set {_coin = newValue}
    }
    /// Returns true if `coin` has been explicitly set.
    public var hasCoin: Bool {return self._coin != nil}
    /// Clears the value of `coin`. Subsequent reads from it will return its default value.
    public mutating func clearCoin() {self._coin = nil}

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _coin: MinterCoin? = nil
  }

  public init() {}
}

public struct MinterWaitListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: String = String()

  public var address: String = String()

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterWaitListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: [MinterWaitListResponse.Wait] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Wait {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var publicKey: String = String()

    public var coin: MinterCoin {
      get {return _coin ?? MinterCoin()}
      set {_coin = newValue}
    }
    /// Returns true if `coin` has been explicitly set.
    public var hasCoin: Bool {return self._coin != nil}
    /// Clears the value of `coin`. Subsequent reads from it will return its default value.
    public mutating func clearCoin() {self._coin = nil}

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _coin: MinterCoin? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api_pb"

extension MinterBlockField: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "transactions"),
    1: .same(proto: "missed"),
    2: .same(proto: "block_reward"),
    3: .same(proto: "size"),
    4: .same(proto: "proposer"),
    5: .same(proto: "validators"),
    6: .same(proto: "evidence"),
  ]
}

extension MinterSwapFrom: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "optimal"),
    1: .same(proto: "bancor"),
    2: .same(proto: "pool"),
  ]
}

extension MinterCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Coin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "symbol"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCoin, rhs: MinterCoin) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBlocksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlocksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_height"),
    2: .standard(proto: "to_height"),
    3: .same(proto: "fields"),
    4: .standard(proto: "failed_txs"),
    5: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fromHeight) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.toHeight) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.fields) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.failedTxs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.fromHeight, fieldNumber: 1)
    }
    if self.toHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.toHeight, fieldNumber: 2)
    }
    if !self.fields.isEmpty {
      try visitor.visitPackedEnumField(value: self.fields, fieldNumber: 3)
    }
    if self.failedTxs != false {
      try visitor.visitSingularBoolField(value: self.failedTxs, fieldNumber: 4)
    }
    if self.events != false {
      try visitor.visitSingularBoolField(value: self.events, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBlocksRequest, rhs: MinterBlocksRequest) -> Bool {
    if lhs.fromHeight != rhs.fromHeight {return false}
    if lhs.toHeight != rhs.toHeight {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.failedTxs != rhs.failedTxs {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBlocksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlocksResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBlocksResponse, rhs: MinterBlocksResponse) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCommissionVotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommissionVotesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_version"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.targetVersion) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.targetVersion, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCommissionVotesRequest, rhs: MinterCommissionVotesRequest) -> Bool {
    if lhs.targetVersion != rhs.targetVersion {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCommissionVotesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommissionVotesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "votes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCommissionVotesResponse, rhs: MinterCommissionVotesResponse) -> Bool {
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCommissionVotesResponse.Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterCommissionVotesResponse.protoMessageName + ".Vote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "price"),
    1: .standard(proto: "public_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.publicKeys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.publicKeys, fieldNumber: 1)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCommissionVotesResponse.Vote, rhs: MinterCommissionVotesResponse.Vote) -> Bool {
    if lhs._price != rhs._price {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterLimitOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitOrderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.orderID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.orderID, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterLimitOrderRequest, rhs: MinterLimitOrderRequest) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitOrderResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "id"),
    1: .standard(proto: "coin_sell"),
    2: .standard(proto: "coin_buy"),
    3: .standard(proto: "want_sell"),
    4: .standard(proto: "want_buy"),
    8: .same(proto: "price"),
    5: .same(proto: "owner"),
    6: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coinSell) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coinBuy) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.wantSell) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.wantBuy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coinSell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coinBuy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.wantSell.isEmpty {
      try visitor.visitSingularStringField(value: self.wantSell, fieldNumber: 3)
    }
    if !self.wantBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.wantBuy, fieldNumber: 4)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 6)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 7)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterLimitOrderResponse, rhs: MinterLimitOrderResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._coinSell != rhs._coinSell {return false}
    if lhs._coinBuy != rhs._coinBuy {return false}
    if lhs.wantSell != rhs.wantSell {return false}
    if lhs.wantBuy != rhs.wantBuy {return false}
    if lhs.price != rhs.price {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterLimitOrdersOfPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitOrdersOfPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_coin"),
    2: .standard(proto: "buy_coin"),
    3: .same(proto: "limit"),
    4: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.sellCoin) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.buyCoin) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sellCoin != 0 {
      try visitor.visitSingularUInt64Field(value: self.sellCoin, fieldNumber: 1)
    }
    if self.buyCoin != 0 {
      try visitor.visitSingularUInt64Field(value: self.buyCoin, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterLimitOrdersOfPoolRequest, rhs: MinterLimitOrdersOfPoolRequest) -> Bool {
    if lhs.sellCoin != rhs.sellCoin {return false}
    if lhs.buyCoin != rhs.buyCoin {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterLimitOrdersOfPoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitOrdersOfPoolResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "pool_price"),
    1: .same(proto: "orders"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.poolPrice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    if !self.poolPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.poolPrice, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterLimitOrdersOfPoolResponse, rhs: MinterLimitOrdersOfPoolResponse) -> Bool {
    if lhs.poolPrice != rhs.poolPrice {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterLimitOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitOrdersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.ids) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.ids, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterLimitOrdersRequest, rhs: MinterLimitOrdersRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterLimitOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitOrdersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterLimitOrdersResponse, rhs: MinterLimitOrdersResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUpdateVotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateVotesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_version"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.targetVersion) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.targetVersion, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUpdateVotesRequest, rhs: MinterUpdateVotesRequest) -> Bool {
    if lhs.targetVersion != rhs.targetVersion {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUpdateVotesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateVotesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "votes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUpdateVotesResponse, rhs: MinterUpdateVotesResponse) -> Bool {
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUpdateVotesResponse.Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterUpdateVotesResponse.protoMessageName + ".Vote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "version"),
    1: .standard(proto: "public_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.publicKeys) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.publicKeys, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUpdateVotesResponse.Vote, rhs: MinterUpdateVotesResponse.Vote) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterVersionNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionNetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterVersionNetworkRequest, rhs: MinterVersionNetworkRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterVersionNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionNetworkResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    3: .same(proto: "versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.current) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.versions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.current.isEmpty {
      try visitor.visitSingularStringField(value: self.current, fieldNumber: 1)
    }
    if !self.versions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.versions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterVersionNetworkResponse, rhs: MinterVersionNetworkResponse) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.versions != rhs.versions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterVersionNetworkResponse.Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterVersionNetworkResponse.protoMessageName + ".Version"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterVersionNetworkResponse.Version, rhs: MinterVersionNetworkResponse.Version) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterPriceCommissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PriceCommissionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterPriceCommissionRequest, rhs: MinterPriceCommissionRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterPriceCommissionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PriceCommissionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "coin"),
    4: .standard(proto: "payload_byte"),
    5: .same(proto: "send"),
    38: .standard(proto: "buy_bancor"),
    39: .standard(proto: "sell_bancor"),
    40: .standard(proto: "sell_all_bancor"),
    41: .standard(proto: "buy_pool_base"),
    53: .standard(proto: "buy_pool_delta"),
    42: .standard(proto: "sell_pool_base"),
    54: .standard(proto: "sell_pool_delta"),
    43: .standard(proto: "sell_all_pool_base"),
    55: .standard(proto: "sell_all_pool_delta"),
    7: .standard(proto: "create_ticker3"),
    8: .standard(proto: "create_ticker4"),
    9: .standard(proto: "create_ticker5"),
    10: .standard(proto: "create_ticker6"),
    11: .standard(proto: "create_ticker7_10"),
    34: .standard(proto: "create_coin"),
    35: .standard(proto: "create_token"),
    36: .standard(proto: "recreate_coin"),
    37: .standard(proto: "recreate_token"),
    13: .standard(proto: "declare_candidacy"),
    14: .same(proto: "delegate"),
    15: .same(proto: "unbond"),
    16: .standard(proto: "redeem_check"),
    44: .standard(proto: "set_candidate_on"),
    45: .standard(proto: "set_candidate_off"),
    18: .standard(proto: "create_multisig"),
    51: .standard(proto: "multisend_base"),
    52: .standard(proto: "multisend_delta"),
    20: .standard(proto: "edit_candidate"),
    21: .standard(proto: "set_halt_block"),
    22: .standard(proto: "edit_ticker_owner"),
    23: .standard(proto: "edit_multisig"),
    25: .standard(proto: "edit_candidate_public_key"),
    48: .standard(proto: "create_swap_pool"),
    49: .standard(proto: "add_liquidity"),
    50: .standard(proto: "remove_liquidity"),
    28: .standard(proto: "edit_candidate_commission"),
    46: .standard(proto: "mint_token"),
    47: .standard(proto: "burn_token"),
    31: .standard(proto: "vote_commission"),
    32: .standard(proto: "vote_update"),
    56: .standard(proto: "failed_tx"),
    57: .standard(proto: "add_limit_order"),
    58: .standard(proto: "remove_limit_order"),
  ]

  fileprivate class _StorageClass {
    var _coin: MinterCoin? = nil
    var _payloadByte: String = String()
    var _send: String = String()
    var _buyBancor: String = String()
    var _sellBancor: String = String()
    var _sellAllBancor: String = String()
    var _buyPoolBase: String = String()
    var _buyPoolDelta: String = String()
    var _sellPoolBase: String = String()
    var _sellPoolDelta: String = String()
    var _sellAllPoolBase: String = String()
    var _sellAllPoolDelta: String = String()
    var _createTicker3: String = String()
    var _createTicker4: String = String()
    var _createTicker5: String = String()
    var _createTicker6: String = String()
    var _createTicker710: String = String()
    var _createCoin: String = String()
    var _createToken: String = String()
    var _recreateCoin: String = String()
    var _recreateToken: String = String()
    var _declareCandidacy: String = String()
    var _delegate: String = String()
    var _unbond: String = String()
    var _redeemCheck: String = String()
    var _setCandidateOn: String = String()
    var _setCandidateOff: String = String()
    var _createMultisig: String = String()
    var _multisendBase: String = String()
    var _multisendDelta: String = String()
    var _editCandidate: String = String()
    var _setHaltBlock: String = String()
    var _editTickerOwner: String = String()
    var _editMultisig: String = String()
    var _editCandidatePublicKey: String = String()
    var _createSwapPool: String = String()
    var _addLiquidity: String = String()
    var _removeLiquidity: String = String()
    var _editCandidateCommission: String = String()
    var _mintToken: String = String()
    var _burnToken: String = String()
    var _voteCommission: String = String()
    var _voteUpdate: String = String()
    var _failedTx: String = String()
    var _addLimitOrder: String = String()
    var _removeLimitOrder: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coin = source._coin
      _payloadByte = source._payloadByte
      _send = source._send
      _buyBancor = source._buyBancor
      _sellBancor = source._sellBancor
      _sellAllBancor = source._sellAllBancor
      _buyPoolBase = source._buyPoolBase
      _buyPoolDelta = source._buyPoolDelta
      _sellPoolBase = source._sellPoolBase
      _sellPoolDelta = source._sellPoolDelta
      _sellAllPoolBase = source._sellAllPoolBase
      _sellAllPoolDelta = source._sellAllPoolDelta
      _createTicker3 = source._createTicker3
      _createTicker4 = source._createTicker4
      _createTicker5 = source._createTicker5
      _createTicker6 = source._createTicker6
      _createTicker710 = source._createTicker710
      _createCoin = source._createCoin
      _createToken = source._createToken
      _recreateCoin = source._recreateCoin
      _recreateToken = source._recreateToken
      _declareCandidacy = source._declareCandidacy
      _delegate = source._delegate
      _unbond = source._unbond
      _redeemCheck = source._redeemCheck
      _setCandidateOn = source._setCandidateOn
      _setCandidateOff = source._setCandidateOff
      _createMultisig = source._createMultisig
      _multisendBase = source._multisendBase
      _multisendDelta = source._multisendDelta
      _editCandidate = source._editCandidate
      _setHaltBlock = source._setHaltBlock
      _editTickerOwner = source._editTickerOwner
      _editMultisig = source._editMultisig
      _editCandidatePublicKey = source._editCandidatePublicKey
      _createSwapPool = source._createSwapPool
      _addLiquidity = source._addLiquidity
      _removeLiquidity = source._removeLiquidity
      _editCandidateCommission = source._editCandidateCommission
      _mintToken = source._mintToken
      _burnToken = source._burnToken
      _voteCommission = source._voteCommission
      _voteUpdate = source._voteUpdate
      _failedTx = source._failedTx
      _addLimitOrder = source._addLimitOrder
      _removeLimitOrder = source._removeLimitOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._coin) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._payloadByte) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._send) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._createTicker3) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._createTicker4) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._createTicker5) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._createTicker6) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._createTicker710) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._declareCandidacy) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._delegate) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._unbond) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._redeemCheck) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._createMultisig) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._editCandidate) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._setHaltBlock) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._editTickerOwner) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._editMultisig) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._editCandidatePublicKey) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._editCandidateCommission) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._voteCommission) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._voteUpdate) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._createCoin) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._createToken) }()
        case 36: try { try decoder.decodeSingularStringField(value: &_storage._recreateCoin) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._recreateToken) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._buyBancor) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._sellBancor) }()
        case 40: try { try decoder.decodeSingularStringField(value: &_storage._sellAllBancor) }()
        case 41: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolBase) }()
        case 42: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolBase) }()
        case 43: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolBase) }()
        case 44: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOn) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOff) }()
        case 46: try { try decoder.decodeSingularStringField(value: &_storage._mintToken) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._burnToken) }()
        case 48: try { try decoder.decodeSingularStringField(value: &_storage._createSwapPool) }()
        case 49: try { try decoder.decodeSingularStringField(value: &_storage._addLiquidity) }()
        case 50: try { try decoder.decodeSingularStringField(value: &_storage._removeLiquidity) }()
        case 51: try { try decoder.decodeSingularStringField(value: &_storage._multisendBase) }()
        case 52: try { try decoder.decodeSingularStringField(value: &_storage._multisendDelta) }()
        case 53: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolDelta) }()
        case 54: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolDelta) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolDelta) }()
        case 56: try { try decoder.decodeSingularStringField(value: &_storage._failedTx) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._addLimitOrder) }()
        case 58: try { try decoder.decodeSingularStringField(value: &_storage._removeLimitOrder) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._coin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._payloadByte.isEmpty {
        try visitor.visitSingularStringField(value: _storage._payloadByte, fieldNumber: 4)
      }
      if !_storage._send.isEmpty {
        try visitor.visitSingularStringField(value: _storage._send, fieldNumber: 5)
      }
      if !_storage._createTicker3.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker3, fieldNumber: 7)
      }
      if !_storage._createTicker4.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker4, fieldNumber: 8)
      }
      if !_storage._createTicker5.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker5, fieldNumber: 9)
      }
      if !_storage._createTicker6.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker6, fieldNumber: 10)
      }
      if !_storage._createTicker710.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker710, fieldNumber: 11)
      }
      if !_storage._declareCandidacy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._declareCandidacy, fieldNumber: 13)
      }
      if !_storage._delegate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegate, fieldNumber: 14)
      }
      if !_storage._unbond.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unbond, fieldNumber: 15)
      }
      if !_storage._redeemCheck.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redeemCheck, fieldNumber: 16)
      }
      if !_storage._createMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createMultisig, fieldNumber: 18)
      }
      if !_storage._editCandidate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidate, fieldNumber: 20)
      }
      if !_storage._setHaltBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setHaltBlock, fieldNumber: 21)
      }
      if !_storage._editTickerOwner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editTickerOwner, fieldNumber: 22)
      }
      if !_storage._editMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editMultisig, fieldNumber: 23)
      }
      if !_storage._editCandidatePublicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidatePublicKey, fieldNumber: 25)
      }
      if !_storage._editCandidateCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidateCommission, fieldNumber: 28)
      }
      if !_storage._voteCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteCommission, fieldNumber: 31)
      }
      if !_storage._voteUpdate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteUpdate, fieldNumber: 32)
      }
      if !_storage._createCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createCoin, fieldNumber: 34)
      }
      if !_storage._createToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createToken, fieldNumber: 35)
      }
      if !_storage._recreateCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateCoin, fieldNumber: 36)
      }
      if !_storage._recreateToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateToken, fieldNumber: 37)
      }
      if !_storage._buyBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyBancor, fieldNumber: 38)
      }
      if !_storage._sellBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellBancor, fieldNumber: 39)
      }
      if !_storage._sellAllBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllBancor, fieldNumber: 40)
      }
      if !_storage._buyPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolBase, fieldNumber: 41)
      }
      if !_storage._sellPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolBase, fieldNumber: 42)
      }
      if !_storage._sellAllPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolBase, fieldNumber: 43)
      }
      if !_storage._setCandidateOn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOn, fieldNumber: 44)
      }
      if !_storage._setCandidateOff.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOff, fieldNumber: 45)
      }
      if !_storage._mintToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mintToken, fieldNumber: 46)
      }
      if !_storage._burnToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._burnToken, fieldNumber: 47)
      }
      if !_storage._createSwapPool.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createSwapPool, fieldNumber: 48)
      }
      if !_storage._addLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLiquidity, fieldNumber: 49)
      }
      if !_storage._removeLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLiquidity, fieldNumber: 50)
      }
      if !_storage._multisendBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendBase, fieldNumber: 51)
      }
      if !_storage._multisendDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendDelta, fieldNumber: 52)
      }
      if !_storage._buyPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolDelta, fieldNumber: 53)
      }
      if !_storage._sellPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolDelta, fieldNumber: 54)
      }
      if !_storage._sellAllPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolDelta, fieldNumber: 55)
      }
      if !_storage._failedTx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._failedTx, fieldNumber: 56)
      }
      if !_storage._addLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLimitOrder, fieldNumber: 57)
      }
      if !_storage._removeLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLimitOrder, fieldNumber: 58)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterPriceCommissionResponse, rhs: MinterPriceCommissionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coin != rhs_storage._coin {return false}
        if _storage._payloadByte != rhs_storage._payloadByte {return false}
        if _storage._send != rhs_storage._send {return false}
        if _storage._buyBancor != rhs_storage._buyBancor {return false}
        if _storage._sellBancor != rhs_storage._sellBancor {return false}
        if _storage._sellAllBancor != rhs_storage._sellAllBancor {return false}
        if _storage._buyPoolBase != rhs_storage._buyPoolBase {return false}
        if _storage._buyPoolDelta != rhs_storage._buyPoolDelta {return false}
        if _storage._sellPoolBase != rhs_storage._sellPoolBase {return false}
        if _storage._sellPoolDelta != rhs_storage._sellPoolDelta {return false}
        if _storage._sellAllPoolBase != rhs_storage._sellAllPoolBase {return false}
        if _storage._sellAllPoolDelta != rhs_storage._sellAllPoolDelta {return false}
        if _storage._createTicker3 != rhs_storage._createTicker3 {return false}
        if _storage._createTicker4 != rhs_storage._createTicker4 {return false}
        if _storage._createTicker5 != rhs_storage._createTicker5 {return false}
        if _storage._createTicker6 != rhs_storage._createTicker6 {return false}
        if _storage._createTicker710 != rhs_storage._createTicker710 {return false}
        if _storage._createCoin != rhs_storage._createCoin {return false}
        if _storage._createToken != rhs_storage._createToken {return false}
        if _storage._recreateCoin != rhs_storage._recreateCoin {return false}
        if _storage._recreateToken != rhs_storage._recreateToken {return false}
        if _storage._declareCandidacy != rhs_storage._declareCandidacy {return false}
        if _storage._delegate != rhs_storage._delegate {return false}
        if _storage._unbond != rhs_storage._unbond {return false}
        if _storage._redeemCheck != rhs_storage._redeemCheck {return false}
        if _storage._setCandidateOn != rhs_storage._setCandidateOn {return false}
        if _storage._setCandidateOff != rhs_storage._setCandidateOff {return false}
        if _storage._createMultisig != rhs_storage._createMultisig {return false}
        if _storage._multisendBase != rhs_storage._multisendBase {return false}
        if _storage._multisendDelta != rhs_storage._multisendDelta {return false}
        if _storage._editCandidate != rhs_storage._editCandidate {return false}
        if _storage._setHaltBlock != rhs_storage._setHaltBlock {return false}
        if _storage._editTickerOwner != rhs_storage._editTickerOwner {return false}
        if _storage._editMultisig != rhs_storage._editMultisig {return false}
        if _storage._editCandidatePublicKey != rhs_storage._editCandidatePublicKey {return false}
        if _storage._createSwapPool != rhs_storage._createSwapPool {return false}
        if _storage._addLiquidity != rhs_storage._addLiquidity {return false}
        if _storage._removeLiquidity != rhs_storage._removeLiquidity {return false}
        if _storage._editCandidateCommission != rhs_storage._editCandidateCommission {return false}
        if _storage._mintToken != rhs_storage._mintToken {return false}
        if _storage._burnToken != rhs_storage._burnToken {return false}
        if _storage._voteCommission != rhs_storage._voteCommission {return false}
        if _storage._voteUpdate != rhs_storage._voteUpdate {return false}
        if _storage._failedTx != rhs_storage._failedTx {return false}
        if _storage._addLimitOrder != rhs_storage._addLimitOrder {return false}
        if _storage._removeLimitOrder != rhs_storage._removeLimitOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSwapPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin0"),
    2: .same(proto: "coin1"),
    4: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.coin0) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.coin1) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coin0 != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin0, fieldNumber: 1)
    }
    if self.coin1 != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin1, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSwapPoolRequest, rhs: MinterSwapPoolRequest) -> Bool {
    if lhs.coin0 != rhs.coin0 {return false}
    if lhs.coin1 != rhs.coin1 {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSwapPoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapPoolResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "price"),
    1: .same(proto: "amount0"),
    2: .same(proto: "amount1"),
    3: .same(proto: "liquidity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount0) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.liquidity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount0.isEmpty {
      try visitor.visitSingularStringField(value: self.amount0, fieldNumber: 1)
    }
    if !self.amount1.isEmpty {
      try visitor.visitSingularStringField(value: self.amount1, fieldNumber: 2)
    }
    if !self.liquidity.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidity, fieldNumber: 3)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSwapPoolResponse, rhs: MinterSwapPoolResponse) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.amount0 != rhs.amount0 {return false}
    if lhs.amount1 != rhs.amount1 {return false}
    if lhs.liquidity != rhs.liquidity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSwapPoolProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapPoolProviderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin0"),
    2: .same(proto: "coin1"),
    3: .same(proto: "provider"),
    4: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.coin0) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.coin1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coin0 != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin0, fieldNumber: 1)
    }
    if self.coin1 != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin1, fieldNumber: 2)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSwapPoolProviderRequest, rhs: MinterSwapPoolProviderRequest) -> Bool {
    if lhs.coin0 != rhs.coin0 {return false}
    if lhs.coin1 != rhs.coin1 {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "protocol_version"),
    1: .same(proto: "id"),
    2: .standard(proto: "listen_addr"),
    3: .same(proto: "network"),
    4: .same(proto: "version"),
    5: .same(proto: "channels"),
    6: .same(proto: "moniker"),
    7: .same(proto: "other"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.listenAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.channels) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._other) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._protocolVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.listenAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.listenAddr, fieldNumber: 2)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    if !self.channels.isEmpty {
      try visitor.visitSingularStringField(value: self.channels, fieldNumber: 5)
    }
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 6)
    }
    try { if let v = self._other {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._protocolVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNodeInfo, rhs: MinterNodeInfo) -> Bool {
    if lhs._protocolVersion != rhs._protocolVersion {return false}
    if lhs.id != rhs.id {return false}
    if lhs.listenAddr != rhs.listenAddr {return false}
    if lhs.network != rhs.network {return false}
    if lhs.version != rhs.version {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.moniker != rhs.moniker {return false}
    if lhs._other != rhs._other {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNodeInfo.ProtocolVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterNodeInfo.protoMessageName + ".ProtocolVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "p2p"),
    1: .same(proto: "block"),
    2: .same(proto: "app"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.block) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.app) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.p2P) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.block != 0 {
      try visitor.visitSingularUInt64Field(value: self.block, fieldNumber: 1)
    }
    if self.app != 0 {
      try visitor.visitSingularUInt64Field(value: self.app, fieldNumber: 2)
    }
    if self.p2P != 0 {
      try visitor.visitSingularUInt64Field(value: self.p2P, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNodeInfo.ProtocolVersion, rhs: MinterNodeInfo.ProtocolVersion) -> Bool {
    if lhs.p2P != rhs.p2P {return false}
    if lhs.block != rhs.block {return false}
    if lhs.app != rhs.app {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNodeInfo.Other: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterNodeInfo.protoMessageName + ".Other"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "tx_index"),
    1: .standard(proto: "rpc_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rpcAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.txIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rpcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rpcAddress, fieldNumber: 1)
    }
    if !self.txIndex.isEmpty {
      try visitor.visitSingularStringField(value: self.txIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNodeInfo.Other, rhs: MinterNodeInfo.Other) -> Bool {
    if lhs.txIndex != rhs.txIndex {return false}
    if lhs.rpcAddress != rhs.rpcAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNetInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "listening"),
    1: .same(proto: "listeners"),
    2: .standard(proto: "count_peers"),
    3: .same(proto: "peers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.listeners) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.countPeers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.listening) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listeners.isEmpty {
      try visitor.visitRepeatedStringField(value: self.listeners, fieldNumber: 1)
    }
    if self.countPeers != 0 {
      try visitor.visitSingularInt64Field(value: self.countPeers, fieldNumber: 2)
    }
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 3)
    }
    if self.listening != false {
      try visitor.visitSingularBoolField(value: self.listening, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNetInfoResponse, rhs: MinterNetInfoResponse) -> Bool {
    if lhs.listening != rhs.listening {return false}
    if lhs.listeners != rhs.listeners {return false}
    if lhs.countPeers != rhs.countPeers {return false}
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNetInfoResponse.Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterNetInfoResponse.protoMessageName + ".Peer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "latest_block_height"),
    4: .standard(proto: "node_info"),
    1: .standard(proto: "is_outbound"),
    2: .standard(proto: "connection_status"),
    3: .standard(proto: "remote_ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isOutbound) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._connectionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.remoteIp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nodeInfo) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._latestBlockHeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isOutbound != false {
      try visitor.visitSingularBoolField(value: self.isOutbound, fieldNumber: 1)
    }
    try { if let v = self._connectionStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.remoteIp.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteIp, fieldNumber: 3)
    }
    try { if let v = self._nodeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._latestBlockHeight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNetInfoResponse.Peer, rhs: MinterNetInfoResponse.Peer) -> Bool {
    if lhs._latestBlockHeight != rhs._latestBlockHeight {return false}
    if lhs._nodeInfo != rhs._nodeInfo {return false}
    if lhs.isOutbound != rhs.isOutbound {return false}
    if lhs._connectionStatus != rhs._connectionStatus {return false}
    if lhs.remoteIp != rhs.remoteIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNetInfoResponse.Peer.ConnectionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterNetInfoResponse.Peer.protoMessageName + ".ConnectionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "duration"),
    1: .same(proto: "SendMonitor"),
    2: .same(proto: "RecvMonitor"),
    3: .same(proto: "channels"),
  ]

  fileprivate class _StorageClass {
    var _duration: UInt64 = 0
    var _sendMonitor: MinterNetInfoResponse.Peer.ConnectionStatus.Monitor? = nil
    var _recvMonitor: MinterNetInfoResponse.Peer.ConnectionStatus.Monitor? = nil
    var _channels: [MinterNetInfoResponse.Peer.ConnectionStatus.Channel] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _duration = source._duration
      _sendMonitor = source._sendMonitor
      _recvMonitor = source._recvMonitor
      _channels = source._channels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._sendMonitor) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._recvMonitor) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._channels) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._duration) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._sendMonitor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._recvMonitor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._channels.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._channels, fieldNumber: 3)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._duration, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNetInfoResponse.Peer.ConnectionStatus, rhs: MinterNetInfoResponse.Peer.ConnectionStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._sendMonitor != rhs_storage._sendMonitor {return false}
        if _storage._recvMonitor != rhs_storage._recvMonitor {return false}
        if _storage._channels != rhs_storage._channels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNetInfoResponse.Peer.ConnectionStatus.Monitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterNetInfoResponse.Peer.ConnectionStatus.protoMessageName + ".Monitor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    13: .same(proto: "active"),
    1: .same(proto: "start"),
    2: .same(proto: "duration"),
    3: .same(proto: "idle"),
    4: .same(proto: "bytes"),
    5: .same(proto: "samples"),
    6: .standard(proto: "inst_rate"),
    7: .standard(proto: "cur_rate"),
    8: .standard(proto: "avg_rate"),
    9: .standard(proto: "peak_rate"),
    10: .standard(proto: "bytes_rem"),
    11: .standard(proto: "time_rem"),
    12: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.idle) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.bytes) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.samples) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.instRate) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.curRate) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.avgRate) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.peakRate) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.bytesRem) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.timeRem) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.progress) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.start.isEmpty {
      try visitor.visitSingularStringField(value: self.start, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.idle != 0 {
      try visitor.visitSingularInt64Field(value: self.idle, fieldNumber: 3)
    }
    if self.bytes != 0 {
      try visitor.visitSingularInt64Field(value: self.bytes, fieldNumber: 4)
    }
    if self.samples != 0 {
      try visitor.visitSingularInt64Field(value: self.samples, fieldNumber: 5)
    }
    if self.instRate != 0 {
      try visitor.visitSingularInt64Field(value: self.instRate, fieldNumber: 6)
    }
    if self.curRate != 0 {
      try visitor.visitSingularInt64Field(value: self.curRate, fieldNumber: 7)
    }
    if self.avgRate != 0 {
      try visitor.visitSingularInt64Field(value: self.avgRate, fieldNumber: 8)
    }
    if self.peakRate != 0 {
      try visitor.visitSingularInt64Field(value: self.peakRate, fieldNumber: 9)
    }
    if self.bytesRem != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesRem, fieldNumber: 10)
    }
    if self.timeRem != 0 {
      try visitor.visitSingularInt64Field(value: self.timeRem, fieldNumber: 11)
    }
    if self.progress != 0 {
      try visitor.visitSingularUInt64Field(value: self.progress, fieldNumber: 12)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNetInfoResponse.Peer.ConnectionStatus.Monitor, rhs: MinterNetInfoResponse.Peer.ConnectionStatus.Monitor) -> Bool {
    if lhs.active != rhs.active {return false}
    if lhs.start != rhs.start {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.idle != rhs.idle {return false}
    if lhs.bytes != rhs.bytes {return false}
    if lhs.samples != rhs.samples {return false}
    if lhs.instRate != rhs.instRate {return false}
    if lhs.curRate != rhs.curRate {return false}
    if lhs.avgRate != rhs.avgRate {return false}
    if lhs.peakRate != rhs.peakRate {return false}
    if lhs.bytesRem != rhs.bytesRem {return false}
    if lhs.timeRem != rhs.timeRem {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterNetInfoResponse.Peer.ConnectionStatus.Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterNetInfoResponse.Peer.ConnectionStatus.protoMessageName + ".Channel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "id"),
    1: .standard(proto: "send_queue_capacity"),
    2: .standard(proto: "send_queue_size"),
    3: .same(proto: "priority"),
    4: .standard(proto: "recently_sent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.sendQueueCapacity) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sendQueueSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.priority) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.recentlySent) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sendQueueCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.sendQueueCapacity, fieldNumber: 1)
    }
    if self.sendQueueSize != 0 {
      try visitor.visitSingularInt64Field(value: self.sendQueueSize, fieldNumber: 2)
    }
    if self.priority != 0 {
      try visitor.visitSingularInt64Field(value: self.priority, fieldNumber: 3)
    }
    if self.recentlySent != 0 {
      try visitor.visitSingularInt64Field(value: self.recentlySent, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterNetInfoResponse.Peer.ConnectionStatus.Channel, rhs: MinterNetInfoResponse.Peer.ConnectionStatus.Channel) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.sendQueueCapacity != rhs.sendQueueCapacity {return false}
    if lhs.sendQueueSize != rhs.sendQueueSize {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs.recentlySent != rhs.recentlySent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .same(proto: "version"),
    11: .same(proto: "network"),
    12: .standard(proto: "initial_height"),
    1: .standard(proto: "latest_block_hash"),
    2: .standard(proto: "latest_app_hash"),
    3: .standard(proto: "latest_block_height"),
    4: .standard(proto: "latest_block_time"),
    5: .standard(proto: "keep_last_states"),
    10: .standard(proto: "total_slashed"),
    6: .standard(proto: "catching_up"),
    7: .standard(proto: "public_key"),
    9: .standard(proto: "node_id"),
    13: .same(proto: "moniker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.latestBlockHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.latestAppHash) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.latestBlockHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.latestBlockTime) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.keepLastStates) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.catchingUp) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.totalSlashed) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.initialHeight) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.latestBlockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.latestBlockHash, fieldNumber: 1)
    }
    if !self.latestAppHash.isEmpty {
      try visitor.visitSingularStringField(value: self.latestAppHash, fieldNumber: 2)
    }
    if self.latestBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.latestBlockHeight, fieldNumber: 3)
    }
    if !self.latestBlockTime.isEmpty {
      try visitor.visitSingularStringField(value: self.latestBlockTime, fieldNumber: 4)
    }
    if self.keepLastStates != 0 {
      try visitor.visitSingularUInt64Field(value: self.keepLastStates, fieldNumber: 5)
    }
    if self.catchingUp != false {
      try visitor.visitSingularBoolField(value: self.catchingUp, fieldNumber: 6)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 7)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 8)
    }
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 9)
    }
    if !self.totalSlashed.isEmpty {
      try visitor.visitSingularStringField(value: self.totalSlashed, fieldNumber: 10)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 11)
    }
    if self.initialHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.initialHeight, fieldNumber: 12)
    }
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterStatusResponse, rhs: MinterStatusResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.network != rhs.network {return false}
    if lhs.initialHeight != rhs.initialHeight {return false}
    if lhs.latestBlockHash != rhs.latestBlockHash {return false}
    if lhs.latestAppHash != rhs.latestAppHash {return false}
    if lhs.latestBlockHeight != rhs.latestBlockHeight {return false}
    if lhs.latestBlockTime != rhs.latestBlockTime {return false}
    if lhs.keepLastStates != rhs.keepLastStates {return false}
    if lhs.totalSlashed != rhs.totalSlashed {return false}
    if lhs.catchingUp != rhs.catchingUp {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.moniker != rhs.moniker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenesisResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_time"),
    2: .standard(proto: "chain_id"),
    6: .standard(proto: "initial_height"),
    3: .standard(proto: "consensus_params"),
    4: .standard(proto: "app_hash"),
    5: .standard(proto: "app_state"),
  ]

  fileprivate class _StorageClass {
    var _genesisTime: String = String()
    var _chainID: String = String()
    var _initialHeight: UInt64 = 0
    var _consensusParams: MinterGenesisResponse.ConsensusParams? = nil
    var _appHash: String = String()
    var _appState: MinterGenesisResponse.AppState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _genesisTime = source._genesisTime
      _chainID = source._chainID
      _initialHeight = source._initialHeight
      _consensusParams = source._consensusParams
      _appHash = source._appHash
      _appState = source._appState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._genesisTime) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._chainID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._consensusParams) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._appHash) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._appState) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._initialHeight) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 1)
      }
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 2)
      }
      try { if let v = _storage._consensusParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appHash, fieldNumber: 4)
      }
      try { if let v = _storage._appState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._initialHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._initialHeight, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse, rhs: MinterGenesisResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._initialHeight != rhs_storage._initialHeight {return false}
        if _storage._consensusParams != rhs_storage._consensusParams {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._appState != rhs_storage._appState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.ConsensusParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.protoMessageName + ".ConsensusParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "evidence"),
    3: .same(proto: "validator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._evidence) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._evidence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.ConsensusParams, rhs: MinterGenesisResponse.ConsensusParams) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs._evidence != rhs._evidence {return false}
    if lhs._validator != rhs._validator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.ConsensusParams.Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.ConsensusParams.protoMessageName + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_bytes"),
    2: .standard(proto: "max_gas"),
    3: .standard(proto: "time_iota_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxBytes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxGas) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timeIotaMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxBytes, fieldNumber: 1)
    }
    if self.maxGas != 0 {
      try visitor.visitSingularInt64Field(value: self.maxGas, fieldNumber: 2)
    }
    if self.timeIotaMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timeIotaMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.ConsensusParams.Block, rhs: MinterGenesisResponse.ConsensusParams.Block) -> Bool {
    if lhs.maxBytes != rhs.maxBytes {return false}
    if lhs.maxGas != rhs.maxGas {return false}
    if lhs.timeIotaMs != rhs.timeIotaMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.ConsensusParams.Evidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.ConsensusParams.protoMessageName + ".Evidence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_age_num_blocks"),
    2: .standard(proto: "max_age_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxAgeNumBlocks) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxAgeDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxAgeNumBlocks != 0 {
      try visitor.visitSingularInt64Field(value: self.maxAgeNumBlocks, fieldNumber: 1)
    }
    if self.maxAgeDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.maxAgeDuration, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.ConsensusParams.Evidence, rhs: MinterGenesisResponse.ConsensusParams.Evidence) -> Bool {
    if lhs.maxAgeNumBlocks != rhs.maxAgeNumBlocks {return false}
    if lhs.maxAgeDuration != rhs.maxAgeDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.ConsensusParams.Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.ConsensusParams.protoMessageName + ".Validator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.pubKeyTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKeyTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pubKeyTypes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.ConsensusParams.Validator, rhs: MinterGenesisResponse.ConsensusParams.Validator) -> Bool {
    if lhs.pubKeyTypes != rhs.pubKeyTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.protoMessageName + ".AppState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    19: .same(proto: "version"),
    10: .same(proto: "note"),
    2: .same(proto: "validators"),
    3: .same(proto: "candidates"),
    5: .same(proto: "coins"),
    6: .standard(proto: "frozen_funds"),
    18: .standard(proto: "block_list_candidates"),
    13: .same(proto: "waitlist"),
    14: .same(proto: "accounts"),
    12: .standard(proto: "halt_blocks"),
    15: .same(proto: "pools"),
    16: .same(proto: "commission"),
    17: .standard(proto: "commission_votes"),
    11: .standard(proto: "used_checks"),
    7: .standard(proto: "max_gas"),
    8: .standard(proto: "total_slashed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.candidates) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.coins) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.frozenFunds) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.maxGas) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.totalSlashed) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.note) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.usedChecks) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.haltBlocks) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.waitlist) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.pools) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._commission) }()
      case 17: try { try decoder.decodeRepeatedMessageField(value: &self.commissionVotes) }()
      case 18: try { try decoder.decodeRepeatedStringField(value: &self.blockListCandidates) }()
      case 19: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    if !self.candidates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candidates, fieldNumber: 3)
    }
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 5)
    }
    if !self.frozenFunds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frozenFunds, fieldNumber: 6)
    }
    if self.maxGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxGas, fieldNumber: 7)
    }
    if !self.totalSlashed.isEmpty {
      try visitor.visitSingularStringField(value: self.totalSlashed, fieldNumber: 8)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularStringField(value: self.note, fieldNumber: 10)
    }
    if !self.usedChecks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usedChecks, fieldNumber: 11)
    }
    if !self.haltBlocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.haltBlocks, fieldNumber: 12)
    }
    if !self.waitlist.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waitlist, fieldNumber: 13)
    }
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 14)
    }
    if !self.pools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pools, fieldNumber: 15)
    }
    try { if let v = self._commission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    if !self.commissionVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commissionVotes, fieldNumber: 17)
    }
    if !self.blockListCandidates.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockListCandidates, fieldNumber: 18)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState, rhs: MinterGenesisResponse.AppState) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.note != rhs.note {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.candidates != rhs.candidates {return false}
    if lhs.coins != rhs.coins {return false}
    if lhs.frozenFunds != rhs.frozenFunds {return false}
    if lhs.blockListCandidates != rhs.blockListCandidates {return false}
    if lhs.waitlist != rhs.waitlist {return false}
    if lhs.accounts != rhs.accounts {return false}
    if lhs.haltBlocks != rhs.haltBlocks {return false}
    if lhs.pools != rhs.pools {return false}
    if lhs._commission != rhs._commission {return false}
    if lhs.commissionVotes != rhs.commissionVotes {return false}
    if lhs.usedChecks != rhs.usedChecks {return false}
    if lhs.maxGas != rhs.maxGas {return false}
    if lhs.totalSlashed != rhs.totalSlashed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Validators: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".Validators"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "total_bip_stake"),
    1: .standard(proto: "public_key"),
    2: .standard(proto: "accum_reward"),
    3: .standard(proto: "absent_times"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accumReward) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.absentTimes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.totalBipStake) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.accumReward.isEmpty {
      try visitor.visitSingularStringField(value: self.accumReward, fieldNumber: 2)
    }
    if !self.absentTimes.isEmpty {
      try visitor.visitSingularStringField(value: self.absentTimes, fieldNumber: 3)
    }
    if !self.totalBipStake.isEmpty {
      try visitor.visitSingularStringField(value: self.totalBipStake, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Validators, rhs: MinterGenesisResponse.AppState.Validators) -> Bool {
    if lhs.totalBipStake != rhs.totalBipStake {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.accumReward != rhs.accumReward {return false}
    if lhs.absentTimes != rhs.absentTimes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Candidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".Candidate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "id"),
    1: .standard(proto: "reward_address"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "control_address"),
    4: .standard(proto: "total_bip_stake"),
    5: .standard(proto: "public_key"),
    6: .same(proto: "commission"),
    7: .same(proto: "stakes"),
    8: .same(proto: "updates"),
    9: .same(proto: "status"),
    11: .standard(proto: "jailed_until"),
    12: .standard(proto: "last_edit_commission_height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rewardAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.controlAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.totalBipStake) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.commission) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.stakes) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.status) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.jailedUntil) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.lastEditCommissionHeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rewardAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAddress, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.controlAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.controlAddress, fieldNumber: 3)
    }
    if !self.totalBipStake.isEmpty {
      try visitor.visitSingularStringField(value: self.totalBipStake, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 5)
    }
    if self.commission != 0 {
      try visitor.visitSingularUInt64Field(value: self.commission, fieldNumber: 6)
    }
    if !self.stakes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stakes, fieldNumber: 7)
    }
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 8)
    }
    if self.status != 0 {
      try visitor.visitSingularInt64Field(value: self.status, fieldNumber: 9)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 10)
    }
    if self.jailedUntil != 0 {
      try visitor.visitSingularInt64Field(value: self.jailedUntil, fieldNumber: 11)
    }
    if self.lastEditCommissionHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEditCommissionHeight, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Candidate, rhs: MinterGenesisResponse.AppState.Candidate) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rewardAddress != rhs.rewardAddress {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.controlAddress != rhs.controlAddress {return false}
    if lhs.totalBipStake != rhs.totalBipStake {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.stakes != rhs.stakes {return false}
    if lhs.updates != rhs.updates {return false}
    if lhs.status != rhs.status {return false}
    if lhs.jailedUntil != rhs.jailedUntil {return false}
    if lhs.lastEditCommissionHeight != rhs.lastEditCommissionHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Candidate.Stake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.Candidate.protoMessageName + ".Stake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "owner"),
    1: .same(proto: "coin"),
    2: .same(proto: "value"),
    3: .standard(proto: "bip_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bipValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.bipValue.isEmpty {
      try visitor.visitSingularStringField(value: self.bipValue, fieldNumber: 3)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Candidate.Stake, rhs: MinterGenesisResponse.AppState.Candidate.Stake) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.bipValue != rhs.bipValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Coin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".Coin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "id"),
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .same(proto: "volume"),
    4: .same(proto: "crr"),
    5: .same(proto: "reserve"),
    6: .standard(proto: "max_supply"),
    7: .same(proto: "version"),
    8: .standard(proto: "owner_address"),
    10: .same(proto: "mintable"),
    11: .same(proto: "burnable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.volume) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.crr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reserve) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.maxSupply) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._ownerAddress) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.mintable) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.burnable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.volume.isEmpty {
      try visitor.visitSingularStringField(value: self.volume, fieldNumber: 3)
    }
    if self.crr != 0 {
      try visitor.visitSingularUInt64Field(value: self.crr, fieldNumber: 4)
    }
    if !self.reserve.isEmpty {
      try visitor.visitSingularStringField(value: self.reserve, fieldNumber: 5)
    }
    if !self.maxSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSupply, fieldNumber: 6)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 7)
    }
    try { if let v = self._ownerAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 9)
    }
    if self.mintable != false {
      try visitor.visitSingularBoolField(value: self.mintable, fieldNumber: 10)
    }
    if self.burnable != false {
      try visitor.visitSingularBoolField(value: self.burnable, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Coin, rhs: MinterGenesisResponse.AppState.Coin) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.crr != rhs.crr {return false}
    if lhs.reserve != rhs.reserve {return false}
    if lhs.maxSupply != rhs.maxSupply {return false}
    if lhs.version != rhs.version {return false}
    if lhs._ownerAddress != rhs._ownerAddress {return false}
    if lhs.mintable != rhs.mintable {return false}
    if lhs.burnable != rhs.burnable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.FrozenFund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".FrozenFund"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "height"),
    1: .same(proto: "address"),
    2: .standard(proto: "candidate_key"),
    6: .standard(proto: "candidate_id"),
    3: .same(proto: "coin"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._candidateKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.candidateID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._candidateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 5)
    }
    if self.candidateID != 0 {
      try visitor.visitSingularUInt64Field(value: self.candidateID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.FrozenFund, rhs: MinterGenesisResponse.AppState.FrozenFund) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.address != rhs.address {return false}
    if lhs._candidateKey != rhs._candidateKey {return false}
    if lhs.candidateID != rhs.candidateID {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Waitlist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".Waitlist"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "candidate_id"),
    2: .same(proto: "owner"),
    3: .same(proto: "coin"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.candidateID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.candidateID != 0 {
      try visitor.visitSingularUInt64Field(value: self.candidateID, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Waitlist, rhs: MinterGenesisResponse.AppState.Waitlist) -> Bool {
    if lhs.candidateID != rhs.candidateID {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .same(proto: "nonce"),
    4: .standard(proto: "multisig_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.balance) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._multisigData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.balance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.balance, fieldNumber: 2)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 3)
    }
    try { if let v = self._multisigData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Account, rhs: MinterGenesisResponse.AppState.Account) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs._multisigData != rhs._multisigData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Account.Balance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.Account.protoMessageName + ".Balance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Account.Balance, rhs: MinterGenesisResponse.AppState.Account.Balance) -> Bool {
    if lhs.coin != rhs.coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Account.MultisigData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.Account.protoMessageName + ".MultisigData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "weights"),
    3: .same(proto: "addresses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.weights) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularUInt64Field(value: self.threshold, fieldNumber: 1)
    }
    if !self.weights.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.weights, fieldNumber: 2)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Account.MultisigData, rhs: MinterGenesisResponse.AppState.Account.MultisigData) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.weights != rhs.weights {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.HaltBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".HaltBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "candidate_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.candidateKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.candidateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.candidateKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.HaltBlock, rhs: MinterGenesisResponse.AppState.HaltBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.candidateKey != rhs.candidateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".Pool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin0"),
    2: .same(proto: "coin1"),
    3: .same(proto: "reserve0"),
    4: .same(proto: "reserve1"),
    5: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.coin0) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.coin1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reserve0) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reserve1) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coin0 != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin0, fieldNumber: 1)
    }
    if self.coin1 != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin1, fieldNumber: 2)
    }
    if !self.reserve0.isEmpty {
      try visitor.visitSingularStringField(value: self.reserve0, fieldNumber: 3)
    }
    if !self.reserve1.isEmpty {
      try visitor.visitSingularStringField(value: self.reserve1, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Pool, rhs: MinterGenesisResponse.AppState.Pool) -> Bool {
    if lhs.coin0 != rhs.coin0 {return false}
    if lhs.coin1 != rhs.coin1 {return false}
    if lhs.reserve0 != rhs.reserve0 {return false}
    if lhs.reserve1 != rhs.reserve1 {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.Commission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".Commission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "coin"),
    4: .standard(proto: "payload_byte"),
    5: .same(proto: "send"),
    38: .standard(proto: "buy_bancor"),
    39: .standard(proto: "sell_bancor"),
    40: .standard(proto: "sell_all_bancor"),
    41: .standard(proto: "buy_pool_base"),
    53: .standard(proto: "buy_pool_delta"),
    42: .standard(proto: "sell_pool_base"),
    54: .standard(proto: "sell_pool_delta"),
    43: .standard(proto: "sell_all_pool_base"),
    55: .standard(proto: "sell_all_pool_delta"),
    7: .standard(proto: "create_ticker3"),
    8: .standard(proto: "create_ticker4"),
    9: .standard(proto: "create_ticker5"),
    10: .standard(proto: "create_ticker6"),
    11: .standard(proto: "create_ticker7_10"),
    34: .standard(proto: "create_coin"),
    35: .standard(proto: "create_token"),
    36: .standard(proto: "recreate_coin"),
    37: .standard(proto: "recreate_token"),
    13: .standard(proto: "declare_candidacy"),
    14: .same(proto: "delegate"),
    15: .same(proto: "unbond"),
    16: .standard(proto: "redeem_check"),
    44: .standard(proto: "set_candidate_on"),
    45: .standard(proto: "set_candidate_off"),
    18: .standard(proto: "create_multisig"),
    51: .standard(proto: "multisend_base"),
    52: .standard(proto: "multisend_delta"),
    20: .standard(proto: "edit_candidate"),
    21: .standard(proto: "set_halt_block"),
    22: .standard(proto: "edit_ticker_owner"),
    23: .standard(proto: "edit_multisig"),
    25: .standard(proto: "edit_candidate_public_key"),
    48: .standard(proto: "create_swap_pool"),
    49: .standard(proto: "add_liquidity"),
    50: .standard(proto: "remove_liquidity"),
    28: .standard(proto: "edit_candidate_commission"),
    46: .standard(proto: "mint_token"),
    47: .standard(proto: "burn_token"),
    31: .standard(proto: "vote_commission"),
    32: .standard(proto: "vote_update"),
    56: .standard(proto: "failed_tx"),
    57: .standard(proto: "add_limit_order"),
    58: .standard(proto: "remove_limit_order"),
  ]

  fileprivate class _StorageClass {
    var _coin: UInt64 = 0
    var _payloadByte: String = String()
    var _send: String = String()
    var _buyBancor: String = String()
    var _sellBancor: String = String()
    var _sellAllBancor: String = String()
    var _buyPoolBase: String = String()
    var _buyPoolDelta: String = String()
    var _sellPoolBase: String = String()
    var _sellPoolDelta: String = String()
    var _sellAllPoolBase: String = String()
    var _sellAllPoolDelta: String = String()
    var _createTicker3: String = String()
    var _createTicker4: String = String()
    var _createTicker5: String = String()
    var _createTicker6: String = String()
    var _createTicker710: String = String()
    var _createCoin: String = String()
    var _createToken: String = String()
    var _recreateCoin: String = String()
    var _recreateToken: String = String()
    var _declareCandidacy: String = String()
    var _delegate: String = String()
    var _unbond: String = String()
    var _redeemCheck: String = String()
    var _setCandidateOn: String = String()
    var _setCandidateOff: String = String()
    var _createMultisig: String = String()
    var _multisendBase: String = String()
    var _multisendDelta: String = String()
    var _editCandidate: String = String()
    var _setHaltBlock: String = String()
    var _editTickerOwner: String = String()
    var _editMultisig: String = String()
    var _editCandidatePublicKey: String = String()
    var _createSwapPool: String = String()
    var _addLiquidity: String = String()
    var _removeLiquidity: String = String()
    var _editCandidateCommission: String = String()
    var _mintToken: String = String()
    var _burnToken: String = String()
    var _voteCommission: String = String()
    var _voteUpdate: String = String()
    var _failedTx: String = String()
    var _addLimitOrder: String = String()
    var _removeLimitOrder: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coin = source._coin
      _payloadByte = source._payloadByte
      _send = source._send
      _buyBancor = source._buyBancor
      _sellBancor = source._sellBancor
      _sellAllBancor = source._sellAllBancor
      _buyPoolBase = source._buyPoolBase
      _buyPoolDelta = source._buyPoolDelta
      _sellPoolBase = source._sellPoolBase
      _sellPoolDelta = source._sellPoolDelta
      _sellAllPoolBase = source._sellAllPoolBase
      _sellAllPoolDelta = source._sellAllPoolDelta
      _createTicker3 = source._createTicker3
      _createTicker4 = source._createTicker4
      _createTicker5 = source._createTicker5
      _createTicker6 = source._createTicker6
      _createTicker710 = source._createTicker710
      _createCoin = source._createCoin
      _createToken = source._createToken
      _recreateCoin = source._recreateCoin
      _recreateToken = source._recreateToken
      _declareCandidacy = source._declareCandidacy
      _delegate = source._delegate
      _unbond = source._unbond
      _redeemCheck = source._redeemCheck
      _setCandidateOn = source._setCandidateOn
      _setCandidateOff = source._setCandidateOff
      _createMultisig = source._createMultisig
      _multisendBase = source._multisendBase
      _multisendDelta = source._multisendDelta
      _editCandidate = source._editCandidate
      _setHaltBlock = source._setHaltBlock
      _editTickerOwner = source._editTickerOwner
      _editMultisig = source._editMultisig
      _editCandidatePublicKey = source._editCandidatePublicKey
      _createSwapPool = source._createSwapPool
      _addLiquidity = source._addLiquidity
      _removeLiquidity = source._removeLiquidity
      _editCandidateCommission = source._editCandidateCommission
      _mintToken = source._mintToken
      _burnToken = source._burnToken
      _voteCommission = source._voteCommission
      _voteUpdate = source._voteUpdate
      _failedTx = source._failedTx
      _addLimitOrder = source._addLimitOrder
      _removeLimitOrder = source._removeLimitOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._coin) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._payloadByte) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._send) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._createTicker3) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._createTicker4) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._createTicker5) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._createTicker6) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._createTicker710) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._declareCandidacy) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._delegate) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._unbond) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._redeemCheck) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._createMultisig) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._editCandidate) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._setHaltBlock) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._editTickerOwner) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._editMultisig) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._editCandidatePublicKey) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._editCandidateCommission) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._voteCommission) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._voteUpdate) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._createCoin) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._createToken) }()
        case 36: try { try decoder.decodeSingularStringField(value: &_storage._recreateCoin) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._recreateToken) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._buyBancor) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._sellBancor) }()
        case 40: try { try decoder.decodeSingularStringField(value: &_storage._sellAllBancor) }()
        case 41: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolBase) }()
        case 42: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolBase) }()
        case 43: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolBase) }()
        case 44: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOn) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOff) }()
        case 46: try { try decoder.decodeSingularStringField(value: &_storage._mintToken) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._burnToken) }()
        case 48: try { try decoder.decodeSingularStringField(value: &_storage._createSwapPool) }()
        case 49: try { try decoder.decodeSingularStringField(value: &_storage._addLiquidity) }()
        case 50: try { try decoder.decodeSingularStringField(value: &_storage._removeLiquidity) }()
        case 51: try { try decoder.decodeSingularStringField(value: &_storage._multisendBase) }()
        case 52: try { try decoder.decodeSingularStringField(value: &_storage._multisendDelta) }()
        case 53: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolDelta) }()
        case 54: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolDelta) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolDelta) }()
        case 56: try { try decoder.decodeSingularStringField(value: &_storage._failedTx) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._addLimitOrder) }()
        case 58: try { try decoder.decodeSingularStringField(value: &_storage._removeLimitOrder) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._coin != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._coin, fieldNumber: 3)
      }
      if !_storage._payloadByte.isEmpty {
        try visitor.visitSingularStringField(value: _storage._payloadByte, fieldNumber: 4)
      }
      if !_storage._send.isEmpty {
        try visitor.visitSingularStringField(value: _storage._send, fieldNumber: 5)
      }
      if !_storage._createTicker3.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker3, fieldNumber: 7)
      }
      if !_storage._createTicker4.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker4, fieldNumber: 8)
      }
      if !_storage._createTicker5.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker5, fieldNumber: 9)
      }
      if !_storage._createTicker6.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker6, fieldNumber: 10)
      }
      if !_storage._createTicker710.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker710, fieldNumber: 11)
      }
      if !_storage._declareCandidacy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._declareCandidacy, fieldNumber: 13)
      }
      if !_storage._delegate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegate, fieldNumber: 14)
      }
      if !_storage._unbond.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unbond, fieldNumber: 15)
      }
      if !_storage._redeemCheck.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redeemCheck, fieldNumber: 16)
      }
      if !_storage._createMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createMultisig, fieldNumber: 18)
      }
      if !_storage._editCandidate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidate, fieldNumber: 20)
      }
      if !_storage._setHaltBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setHaltBlock, fieldNumber: 21)
      }
      if !_storage._editTickerOwner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editTickerOwner, fieldNumber: 22)
      }
      if !_storage._editMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editMultisig, fieldNumber: 23)
      }
      if !_storage._editCandidatePublicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidatePublicKey, fieldNumber: 25)
      }
      if !_storage._editCandidateCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidateCommission, fieldNumber: 28)
      }
      if !_storage._voteCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteCommission, fieldNumber: 31)
      }
      if !_storage._voteUpdate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteUpdate, fieldNumber: 32)
      }
      if !_storage._createCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createCoin, fieldNumber: 34)
      }
      if !_storage._createToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createToken, fieldNumber: 35)
      }
      if !_storage._recreateCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateCoin, fieldNumber: 36)
      }
      if !_storage._recreateToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateToken, fieldNumber: 37)
      }
      if !_storage._buyBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyBancor, fieldNumber: 38)
      }
      if !_storage._sellBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellBancor, fieldNumber: 39)
      }
      if !_storage._sellAllBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllBancor, fieldNumber: 40)
      }
      if !_storage._buyPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolBase, fieldNumber: 41)
      }
      if !_storage._sellPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolBase, fieldNumber: 42)
      }
      if !_storage._sellAllPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolBase, fieldNumber: 43)
      }
      if !_storage._setCandidateOn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOn, fieldNumber: 44)
      }
      if !_storage._setCandidateOff.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOff, fieldNumber: 45)
      }
      if !_storage._mintToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mintToken, fieldNumber: 46)
      }
      if !_storage._burnToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._burnToken, fieldNumber: 47)
      }
      if !_storage._createSwapPool.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createSwapPool, fieldNumber: 48)
      }
      if !_storage._addLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLiquidity, fieldNumber: 49)
      }
      if !_storage._removeLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLiquidity, fieldNumber: 50)
      }
      if !_storage._multisendBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendBase, fieldNumber: 51)
      }
      if !_storage._multisendDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendDelta, fieldNumber: 52)
      }
      if !_storage._buyPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolDelta, fieldNumber: 53)
      }
      if !_storage._sellPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolDelta, fieldNumber: 54)
      }
      if !_storage._sellAllPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolDelta, fieldNumber: 55)
      }
      if !_storage._failedTx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._failedTx, fieldNumber: 56)
      }
      if !_storage._addLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLimitOrder, fieldNumber: 57)
      }
      if !_storage._removeLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLimitOrder, fieldNumber: 58)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.Commission, rhs: MinterGenesisResponse.AppState.Commission) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coin != rhs_storage._coin {return false}
        if _storage._payloadByte != rhs_storage._payloadByte {return false}
        if _storage._send != rhs_storage._send {return false}
        if _storage._buyBancor != rhs_storage._buyBancor {return false}
        if _storage._sellBancor != rhs_storage._sellBancor {return false}
        if _storage._sellAllBancor != rhs_storage._sellAllBancor {return false}
        if _storage._buyPoolBase != rhs_storage._buyPoolBase {return false}
        if _storage._buyPoolDelta != rhs_storage._buyPoolDelta {return false}
        if _storage._sellPoolBase != rhs_storage._sellPoolBase {return false}
        if _storage._sellPoolDelta != rhs_storage._sellPoolDelta {return false}
        if _storage._sellAllPoolBase != rhs_storage._sellAllPoolBase {return false}
        if _storage._sellAllPoolDelta != rhs_storage._sellAllPoolDelta {return false}
        if _storage._createTicker3 != rhs_storage._createTicker3 {return false}
        if _storage._createTicker4 != rhs_storage._createTicker4 {return false}
        if _storage._createTicker5 != rhs_storage._createTicker5 {return false}
        if _storage._createTicker6 != rhs_storage._createTicker6 {return false}
        if _storage._createTicker710 != rhs_storage._createTicker710 {return false}
        if _storage._createCoin != rhs_storage._createCoin {return false}
        if _storage._createToken != rhs_storage._createToken {return false}
        if _storage._recreateCoin != rhs_storage._recreateCoin {return false}
        if _storage._recreateToken != rhs_storage._recreateToken {return false}
        if _storage._declareCandidacy != rhs_storage._declareCandidacy {return false}
        if _storage._delegate != rhs_storage._delegate {return false}
        if _storage._unbond != rhs_storage._unbond {return false}
        if _storage._redeemCheck != rhs_storage._redeemCheck {return false}
        if _storage._setCandidateOn != rhs_storage._setCandidateOn {return false}
        if _storage._setCandidateOff != rhs_storage._setCandidateOff {return false}
        if _storage._createMultisig != rhs_storage._createMultisig {return false}
        if _storage._multisendBase != rhs_storage._multisendBase {return false}
        if _storage._multisendDelta != rhs_storage._multisendDelta {return false}
        if _storage._editCandidate != rhs_storage._editCandidate {return false}
        if _storage._setHaltBlock != rhs_storage._setHaltBlock {return false}
        if _storage._editTickerOwner != rhs_storage._editTickerOwner {return false}
        if _storage._editMultisig != rhs_storage._editMultisig {return false}
        if _storage._editCandidatePublicKey != rhs_storage._editCandidatePublicKey {return false}
        if _storage._createSwapPool != rhs_storage._createSwapPool {return false}
        if _storage._addLiquidity != rhs_storage._addLiquidity {return false}
        if _storage._removeLiquidity != rhs_storage._removeLiquidity {return false}
        if _storage._editCandidateCommission != rhs_storage._editCandidateCommission {return false}
        if _storage._mintToken != rhs_storage._mintToken {return false}
        if _storage._burnToken != rhs_storage._burnToken {return false}
        if _storage._voteCommission != rhs_storage._voteCommission {return false}
        if _storage._voteUpdate != rhs_storage._voteUpdate {return false}
        if _storage._failedTx != rhs_storage._failedTx {return false}
        if _storage._addLimitOrder != rhs_storage._addLimitOrder {return false}
        if _storage._removeLimitOrder != rhs_storage._removeLimitOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterGenesisResponse.AppState.CommissionVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterGenesisResponse.AppState.protoMessageName + ".CommissionVote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "votes"),
    3: .same(proto: "commission"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.votes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._commission) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.votes, fieldNumber: 2)
    }
    try { if let v = self._commission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterGenesisResponse.AppState.CommissionVote, rhs: MinterGenesisResponse.AppState.CommissionVote) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs._commission != rhs._commission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMinGasPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MinGasPriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "min_gas_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.minGasPrice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minGasPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.minGasPrice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMinGasPriceResponse, rhs: MinterMinGasPriceResponse) -> Bool {
    if lhs.minGasPrice != rhs.minGasPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "fields"),
    3: .standard(proto: "failed_txs"),
    4: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.fields) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.failedTxs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitPackedEnumField(value: self.fields, fieldNumber: 2)
    }
    if self.failedTxs != false {
      try visitor.visitSingularBoolField(value: self.failedTxs, fieldNumber: 3)
    }
    if self.events != false {
      try visitor.visitSingularBoolField(value: self.events, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBlockRequest, rhs: MinterBlockRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.failedTxs != rhs.failedTxs {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .same(proto: "time"),
    4: .standard(proto: "transaction_count"),
    6: .same(proto: "transactions"),
    7: .standard(proto: "block_reward"),
    8: .same(proto: "size"),
    9: .same(proto: "proposer"),
    10: .same(proto: "validators"),
    13: .same(proto: "evidence"),
    12: .same(proto: "missed"),
    14: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.time) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.transactionCount) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.blockReward) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.proposer) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 12: try { try decoder.decodeRepeatedStringField(value: &self.missed) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._evidence) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 3)
    }
    if self.transactionCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.transactionCount, fieldNumber: 4)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 6)
    }
    if !self.blockReward.isEmpty {
      try visitor.visitSingularStringField(value: self.blockReward, fieldNumber: 7)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 8)
    }
    if !self.proposer.isEmpty {
      try visitor.visitSingularStringField(value: self.proposer, fieldNumber: 9)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 10)
    }
    if !self.missed.isEmpty {
      try visitor.visitRepeatedStringField(value: self.missed, fieldNumber: 12)
    }
    try { if let v = self._evidence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBlockResponse, rhs: MinterBlockResponse) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.time != rhs.time {return false}
    if lhs.transactionCount != rhs.transactionCount {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.blockReward != rhs.blockReward {return false}
    if lhs.size != rhs.size {return false}
    if lhs.proposer != rhs.proposer {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs._evidence != rhs._evidence {return false}
    if lhs.missed != rhs.missed {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBlockResponse.Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterBlockResponse.protoMessageName + ".Validator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "signed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.signed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if self.signed != false {
      try visitor.visitSingularBoolField(value: self.signed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBlockResponse.Validator, rhs: MinterBlockResponse.Validator) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.signed != rhs.signed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBlockResponse.Evidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterBlockResponse.protoMessageName + ".Evidence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "evidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.evidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.evidence.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evidence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBlockResponse.Evidence, rhs: MinterBlockResponse.Evidence) -> Bool {
    if lhs.evidence != rhs.evidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMaxGasPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaxGasPriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMaxGasPriceRequest, rhs: MinterMaxGasPriceRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMaxGasPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaxGasPriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "max_gas_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxGasPrice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxGasPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxGasPrice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMaxGasPriceResponse, rhs: MinterMaxGasPriceResponse) -> Bool {
    if lhs.maxGasPrice != rhs.maxGasPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "height"),
    4: .same(proto: "delegated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.delegated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.delegated != false {
      try visitor.visitSingularBoolField(value: self.delegated, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddressRequest, rhs: MinterAddressRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.height != rhs.height {return false}
    if lhs.delegated != rhs.delegated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddressBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressBalance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .same(proto: "value"),
    3: .standard(proto: "bip_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bipValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.bipValue.isEmpty {
      try visitor.visitSingularStringField(value: self.bipValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddressBalance, rhs: MinterAddressBalance) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.bipValue != rhs.bipValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddressDelegatedBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressDelegatedBalance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .same(proto: "value"),
    3: .standard(proto: "bip_value"),
    4: .standard(proto: "delegate_bip_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bipValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.delegateBipValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.bipValue.isEmpty {
      try visitor.visitSingularStringField(value: self.bipValue, fieldNumber: 3)
    }
    if !self.delegateBipValue.isEmpty {
      try visitor.visitSingularStringField(value: self.delegateBipValue, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddressDelegatedBalance, rhs: MinterAddressDelegatedBalance) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.bipValue != rhs.bipValue {return false}
    if lhs.delegateBipValue != rhs.delegateBipValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    3: .same(proto: "delegated"),
    4: .same(proto: "total"),
    2: .standard(proto: "transaction_count"),
    5: .standard(proto: "bip_value"),
    6: .same(proto: "multisig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.balance) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.transactionCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.delegated) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.total) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bipValue) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._multisig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.balance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.balance, fieldNumber: 1)
    }
    if self.transactionCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.transactionCount, fieldNumber: 2)
    }
    if !self.delegated.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delegated, fieldNumber: 3)
    }
    if !self.total.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.total, fieldNumber: 4)
    }
    if !self.bipValue.isEmpty {
      try visitor.visitSingularStringField(value: self.bipValue, fieldNumber: 5)
    }
    try { if let v = self._multisig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddressResponse, rhs: MinterAddressResponse) -> Bool {
    if lhs.balance != rhs.balance {return false}
    if lhs.delegated != rhs.delegated {return false}
    if lhs.total != rhs.total {return false}
    if lhs.transactionCount != rhs.transactionCount {return false}
    if lhs.bipValue != rhs.bipValue {return false}
    if lhs._multisig != rhs._multisig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMultisig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Multisig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "weights"),
    3: .same(proto: "addresses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.weights) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularUInt64Field(value: self.threshold, fieldNumber: 1)
    }
    if !self.weights.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.weights, fieldNumber: 2)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMultisig, rhs: MinterMultisig) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.weights != rhs.weights {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddressesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .same(proto: "height"),
    4: .same(proto: "delegated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.delegated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.delegated != false {
      try visitor.visitSingularBoolField(value: self.delegated, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddressesRequest, rhs: MinterAddressesRequest) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.height != rhs.height {return false}
    if lhs.delegated != rhs.delegated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddressesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "addresses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MinterAddressesResponse.Result>.self, value: &self.addresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MinterAddressesResponse.Result>.self, value: self.addresses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddressesResponse, rhs: MinterAddressesResponse) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddressesResponse.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterAddressesResponse.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "balance"),
    6: .same(proto: "delegated"),
    4: .same(proto: "total"),
    3: .standard(proto: "transaction_count"),
    5: .standard(proto: "bip_value"),
    7: .same(proto: "multisig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.balance) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.transactionCount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.total) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bipValue) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.delegated) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._multisig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.balance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.balance, fieldNumber: 2)
    }
    if self.transactionCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.transactionCount, fieldNumber: 3)
    }
    if !self.total.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.total, fieldNumber: 4)
    }
    if !self.bipValue.isEmpty {
      try visitor.visitSingularStringField(value: self.bipValue, fieldNumber: 5)
    }
    if !self.delegated.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delegated, fieldNumber: 6)
    }
    try { if let v = self._multisig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddressesResponse.Result, rhs: MinterAddressesResponse.Result) -> Bool {
    if lhs.balance != rhs.balance {return false}
    if lhs.delegated != rhs.delegated {return false}
    if lhs.total != rhs.total {return false}
    if lhs.transactionCount != rhs.transactionCount {return false}
    if lhs.bipValue != rhs.bipValue {return false}
    if lhs._multisig != rhs._multisig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCandidateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "height"),
    4: .standard(proto: "not_show_stakes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.notShowStakes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.notShowStakes != false {
      try visitor.visitSingularBoolField(value: self.notShowStakes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCandidateRequest, rhs: MinterCandidateRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.height != rhs.height {return false}
    if lhs.notShowStakes != rhs.notShowStakes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCandidateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    14: .same(proto: "id"),
    1: .standard(proto: "reward_address"),
    10: .standard(proto: "owner_address"),
    11: .standard(proto: "control_address"),
    2: .standard(proto: "total_stake"),
    3: .standard(proto: "public_key"),
    4: .same(proto: "commission"),
    7: .standard(proto: "used_slots"),
    8: .standard(proto: "uniq_users"),
    9: .standard(proto: "min_stake"),
    5: .same(proto: "stakes"),
    6: .same(proto: "status"),
    12: .same(proto: "validator"),
    13: .standard(proto: "jailed_until"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rewardAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.totalStake) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.commission) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.stakes) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.status) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._usedSlots) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._uniqUsers) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._minStake) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.controlAddress) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.validator) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.jailedUntil) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rewardAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAddress, fieldNumber: 1)
    }
    if !self.totalStake.isEmpty {
      try visitor.visitSingularStringField(value: self.totalStake, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if self.commission != 0 {
      try visitor.visitSingularUInt64Field(value: self.commission, fieldNumber: 4)
    }
    if !self.stakes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stakes, fieldNumber: 5)
    }
    if self.status != 0 {
      try visitor.visitSingularUInt64Field(value: self.status, fieldNumber: 6)
    }
    try { if let v = self._usedSlots {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._uniqUsers {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._minStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 10)
    }
    if !self.controlAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.controlAddress, fieldNumber: 11)
    }
    if self.validator != false {
      try visitor.visitSingularBoolField(value: self.validator, fieldNumber: 12)
    }
    if self.jailedUntil != 0 {
      try visitor.visitSingularUInt64Field(value: self.jailedUntil, fieldNumber: 13)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCandidateResponse, rhs: MinterCandidateResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rewardAddress != rhs.rewardAddress {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.controlAddress != rhs.controlAddress {return false}
    if lhs.totalStake != rhs.totalStake {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs._usedSlots != rhs._usedSlots {return false}
    if lhs._uniqUsers != rhs._uniqUsers {return false}
    if lhs._minStake != rhs._minStake {return false}
    if lhs.stakes != rhs.stakes {return false}
    if lhs.status != rhs.status {return false}
    if lhs.validator != rhs.validator {return false}
    if lhs.jailedUntil != rhs.jailedUntil {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCandidateResponse.Stake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterCandidateResponse.protoMessageName + ".Stake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "coin"),
    3: .same(proto: "value"),
    4: .standard(proto: "bip_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bipValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    if !self.bipValue.isEmpty {
      try visitor.visitSingularStringField(value: self.bipValue, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCandidateResponse.Stake, rhs: MinterCandidateResponse.Stake) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.bipValue != rhs.bipValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCandidatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidatesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "include_stakes"),
    4: .standard(proto: "not_show_stakes"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeStakes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.notShowStakes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.includeStakes != false {
      try visitor.visitSingularBoolField(value: self.includeStakes, fieldNumber: 2)
    }
    if self.status != .all {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if self.notShowStakes != false {
      try visitor.visitSingularBoolField(value: self.notShowStakes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCandidatesRequest, rhs: MinterCandidatesRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.includeStakes != rhs.includeStakes {return false}
    if lhs.notShowStakes != rhs.notShowStakes {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCandidatesRequest.CandidateStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "all"),
    1: .same(proto: "off"),
    2: .same(proto: "on"),
    3: .same(proto: "validator"),
  ]
}

extension MinterCandidatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "candidates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.candidates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candidates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candidates, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCandidatesResponse, rhs: MinterCandidatesResponse) -> Bool {
    if lhs.candidates != rhs.candidates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCoinIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoinIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCoinIdRequest, rhs: MinterCoinIdRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCoinInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoinInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "symbol"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCoinInfoRequest, rhs: MinterCoinInfoRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCoinInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoinInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "id"),
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .same(proto: "volume"),
    4: .same(proto: "crr"),
    5: .standard(proto: "reserve_balance"),
    8: .standard(proto: "max_supply"),
    7: .standard(proto: "owner_address"),
    9: .same(proto: "mintable"),
    10: .same(proto: "burnable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.volume) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.crr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reserveBalance) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._ownerAddress) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.maxSupply) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.mintable) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.burnable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.volume.isEmpty {
      try visitor.visitSingularStringField(value: self.volume, fieldNumber: 3)
    }
    if self.crr != 0 {
      try visitor.visitSingularUInt64Field(value: self.crr, fieldNumber: 4)
    }
    if !self.reserveBalance.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveBalance, fieldNumber: 5)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 6)
    }
    try { if let v = self._ownerAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.maxSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSupply, fieldNumber: 8)
    }
    if self.mintable != false {
      try visitor.visitSingularBoolField(value: self.mintable, fieldNumber: 9)
    }
    if self.burnable != false {
      try visitor.visitSingularBoolField(value: self.burnable, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCoinInfoResponse, rhs: MinterCoinInfoResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.crr != rhs.crr {return false}
    if lhs.reserveBalance != rhs.reserveBalance {return false}
    if lhs.maxSupply != rhs.maxSupply {return false}
    if lhs._ownerAddress != rhs._ownerAddress {return false}
    if lhs.mintable != rhs.mintable {return false}
    if lhs.burnable != rhs.burnable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSendTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendTransactionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "log"),
    4: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt64Field(value: self.code, fieldNumber: 1)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSendTransactionResponse, rhs: MinterSendTransactionResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.log != rhs.log {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSendTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendTransactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tx) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularStringField(value: self.tx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSendTransactionRequest, rhs: MinterSendTransactionRequest) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "raw_tx"),
    3: .same(proto: "height"),
    4: .same(proto: "index"),
    5: .same(proto: "from"),
    6: .same(proto: "nonce"),
    7: .same(proto: "gas"),
    8: .standard(proto: "gas_price"),
    9: .standard(proto: "gas_coin"),
    17: .standard(proto: "type_hex"),
    10: .same(proto: "type"),
    11: .same(proto: "data"),
    12: .same(proto: "payload"),
    16: .standard(proto: "service_data"),
    13: .same(proto: "tags"),
    14: .same(proto: "code"),
    15: .same(proto: "log"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _rawTx: String = String()
    var _height: UInt64 = 0
    var _index: UInt64 = 0
    var _from: String = String()
    var _nonce: UInt64 = 0
    var _gas: UInt64 = 0
    var _gasPrice: UInt64 = 0
    var _gasCoin: MinterCoin? = nil
    var _typeHex: String = String()
    var _type: UInt64 = 0
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _payload: Data = Data()
    var _serviceData: Data = Data()
    var _tags: Dictionary<String,String> = [:]
    var _code: UInt64 = 0
    var _log: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _rawTx = source._rawTx
      _height = source._height
      _index = source._index
      _from = source._from
      _nonce = source._nonce
      _gas = source._gas
      _gasPrice = source._gasPrice
      _gasCoin = source._gasCoin
      _typeHex = source._typeHex
      _type = source._type
      _data = source._data
      _payload = source._payload
      _serviceData = source._serviceData
      _tags = source._tags
      _code = source._code
      _log = source._log
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._rawTx) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._height) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._index) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._from) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._nonce) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._gas) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._gasPrice) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._gasCoin) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._type) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._payload) }()
        case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._tags) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._code) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._log) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._serviceData) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._typeHex) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if !_storage._rawTx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rawTx, fieldNumber: 2)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 3)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._index, fieldNumber: 4)
      }
      if !_storage._from.isEmpty {
        try visitor.visitSingularStringField(value: _storage._from, fieldNumber: 5)
      }
      if _storage._nonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nonce, fieldNumber: 6)
      }
      if _storage._gas != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gas, fieldNumber: 7)
      }
      if _storage._gasPrice != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasPrice, fieldNumber: 8)
      }
      try { if let v = _storage._gasCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._type != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._type, fieldNumber: 10)
      }
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 12)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._tags, fieldNumber: 13)
      }
      if _storage._code != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._code, fieldNumber: 14)
      }
      if !_storage._log.isEmpty {
        try visitor.visitSingularStringField(value: _storage._log, fieldNumber: 15)
      }
      if !_storage._serviceData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._serviceData, fieldNumber: 16)
      }
      if !_storage._typeHex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._typeHex, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterTransactionResponse, rhs: MinterTransactionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._rawTx != rhs_storage._rawTx {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._gas != rhs_storage._gas {return false}
        if _storage._gasPrice != rhs_storage._gasPrice {return false}
        if _storage._gasCoin != rhs_storage._gasCoin {return false}
        if _storage._typeHex != rhs_storage._typeHex {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._serviceData != rhs_storage._serviceData {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._log != rhs_storage._log {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterTransactionResponse.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_"),
    1: .same(proto: "Send"),
    2: .same(proto: "SellCoin"),
    3: .same(proto: "SellAllCoin"),
    4: .same(proto: "BuyCoin"),
    5: .same(proto: "CreateCoin"),
    6: .same(proto: "DeclareCandidacy"),
    7: .same(proto: "Delegate"),
    8: .same(proto: "Unbond"),
    9: .same(proto: "RedeemCheck"),
    10: .same(proto: "SetCandidateOnline"),
    11: .same(proto: "SetCandidateOffline"),
    12: .same(proto: "CreateMultisig"),
    13: .same(proto: "Multisend"),
    14: .same(proto: "EditCandidate"),
    15: .same(proto: "SetHaltBlock"),
    16: .same(proto: "RecreateCoin"),
    17: .same(proto: "EditCoinOwner"),
    18: .same(proto: "EditMultisig"),
    19: .same(proto: "PriceVote"),
    20: .same(proto: "EditCandidatePublicKey"),
    21: .same(proto: "AddLiquidity"),
    22: .same(proto: "RemoveLiquidity"),
    23: .same(proto: "SellSwapPool"),
    24: .same(proto: "BuySwapPool"),
    25: .same(proto: "SellAllSwapPool"),
    26: .same(proto: "EditCommissionCandidate"),
    27: .same(proto: "MoveStake"),
    28: .same(proto: "MintToken"),
    29: .same(proto: "BurnToken"),
    30: .same(proto: "CreateToken"),
    31: .same(proto: "RecreateToken"),
    32: .same(proto: "VoteCommission"),
    33: .same(proto: "VoteUpdate"),
    34: .same(proto: "CreateSwapPool"),
    35: .same(proto: "AddLimitOrder"),
    36: .same(proto: "RemoveLimitOrder"),
  ]
}

extension MinterTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterTransactionRequest, rhs: MinterTransactionRequest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterTransactionsResponse, rhs: MinterTransactionsResponse) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterTransactionsRequest, rhs: MinterTransactionsRequest) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateCoinBuyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateCoinBuyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_id_to_buy"),
    5: .standard(proto: "coin_to_buy"),
    2: .standard(proto: "coin_id_to_sell"),
    6: .standard(proto: "coin_to_sell"),
    3: .standard(proto: "value_to_buy"),
    4: .same(proto: "height"),
    9: .standard(proto: "coin_id_commission"),
    10: .standard(proto: "coin_commission"),
    8: .standard(proto: "swap_from"),
    11: .same(proto: "route"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.buy != nil {try decoder.handleConflictingOneOf()}
          self.buy = .coinIDToBuy(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.sell != nil {try decoder.handleConflictingOneOf()}
          self.sell = .coinIDToSell(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.valueToBuy) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.buy != nil {try decoder.handleConflictingOneOf()}
          self.buy = .coinToBuy(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sell != nil {try decoder.handleConflictingOneOf()}
          self.sell = .coinToSell(v)
        }
      }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.swapFrom) }()
      case 9: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.commission != nil {try decoder.handleConflictingOneOf()}
          self.commission = .coinIDCommission(v)
        }
      }()
      case 10: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.commission != nil {try decoder.handleConflictingOneOf()}
          self.commission = .coinCommission(v)
        }
      }()
      case 11: try { try decoder.decodeRepeatedUInt64Field(value: &self.route) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .coinIDToBuy(let v)? = self.buy {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if case .coinIDToSell(let v)? = self.sell {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.valueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToBuy, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 4)
    }
    try { if case .coinToBuy(let v)? = self.buy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if case .coinToSell(let v)? = self.sell {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if self.swapFrom != .optimal {
      try visitor.visitSingularEnumField(value: self.swapFrom, fieldNumber: 8)
    }
    switch self.commission {
    case .coinIDCommission?: try {
      guard case .coinIDCommission(let v)? = self.commission else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    }()
    case .coinCommission?: try {
      guard case .coinCommission(let v)? = self.commission else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    if !self.route.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.route, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateCoinBuyRequest, rhs: MinterEstimateCoinBuyRequest) -> Bool {
    if lhs.buy != rhs.buy {return false}
    if lhs.sell != rhs.sell {return false}
    if lhs.valueToBuy != rhs.valueToBuy {return false}
    if lhs.height != rhs.height {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.swapFrom != rhs.swapFrom {return false}
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateCoinBuyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateCoinBuyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "will_pay"),
    2: .same(proto: "commission"),
    3: .standard(proto: "swap_from"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.willPay) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commission) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.swapFrom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.willPay.isEmpty {
      try visitor.visitSingularStringField(value: self.willPay, fieldNumber: 1)
    }
    if !self.commission.isEmpty {
      try visitor.visitSingularStringField(value: self.commission, fieldNumber: 2)
    }
    if self.swapFrom != .optimal {
      try visitor.visitSingularEnumField(value: self.swapFrom, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateCoinBuyResponse, rhs: MinterEstimateCoinBuyResponse) -> Bool {
    if lhs.willPay != rhs.willPay {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.swapFrom != rhs.swapFrom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateCoinSellRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateCoinSellRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_id_to_buy"),
    5: .standard(proto: "coin_to_buy"),
    2: .standard(proto: "coin_id_to_sell"),
    6: .standard(proto: "coin_to_sell"),
    3: .standard(proto: "value_to_sell"),
    4: .same(proto: "height"),
    9: .standard(proto: "coin_id_commission"),
    10: .standard(proto: "coin_commission"),
    8: .standard(proto: "swap_from"),
    11: .same(proto: "route"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.buy != nil {try decoder.handleConflictingOneOf()}
          self.buy = .coinIDToBuy(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.sell != nil {try decoder.handleConflictingOneOf()}
          self.sell = .coinIDToSell(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.valueToSell) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.buy != nil {try decoder.handleConflictingOneOf()}
          self.buy = .coinToBuy(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sell != nil {try decoder.handleConflictingOneOf()}
          self.sell = .coinToSell(v)
        }
      }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.swapFrom) }()
      case 9: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.commission != nil {try decoder.handleConflictingOneOf()}
          self.commission = .coinIDCommission(v)
        }
      }()
      case 10: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.commission != nil {try decoder.handleConflictingOneOf()}
          self.commission = .coinCommission(v)
        }
      }()
      case 11: try { try decoder.decodeRepeatedUInt64Field(value: &self.route) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .coinIDToBuy(let v)? = self.buy {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if case .coinIDToSell(let v)? = self.sell {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.valueToSell.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToSell, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 4)
    }
    try { if case .coinToBuy(let v)? = self.buy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if case .coinToSell(let v)? = self.sell {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if self.swapFrom != .optimal {
      try visitor.visitSingularEnumField(value: self.swapFrom, fieldNumber: 8)
    }
    switch self.commission {
    case .coinIDCommission?: try {
      guard case .coinIDCommission(let v)? = self.commission else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    }()
    case .coinCommission?: try {
      guard case .coinCommission(let v)? = self.commission else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    if !self.route.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.route, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateCoinSellRequest, rhs: MinterEstimateCoinSellRequest) -> Bool {
    if lhs.buy != rhs.buy {return false}
    if lhs.sell != rhs.sell {return false}
    if lhs.valueToSell != rhs.valueToSell {return false}
    if lhs.height != rhs.height {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.swapFrom != rhs.swapFrom {return false}
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateCoinSellResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateCoinSellResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "will_get"),
    2: .same(proto: "commission"),
    3: .standard(proto: "swap_from"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.willGet) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commission) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.swapFrom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.willGet.isEmpty {
      try visitor.visitSingularStringField(value: self.willGet, fieldNumber: 1)
    }
    if !self.commission.isEmpty {
      try visitor.visitSingularStringField(value: self.commission, fieldNumber: 2)
    }
    if self.swapFrom != .optimal {
      try visitor.visitSingularEnumField(value: self.swapFrom, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateCoinSellResponse, rhs: MinterEstimateCoinSellResponse) -> Bool {
    if lhs.willGet != rhs.willGet {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.swapFrom != rhs.swapFrom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateCoinSellAllRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateCoinSellAllRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_id_to_buy"),
    7: .standard(proto: "coin_to_buy"),
    2: .standard(proto: "coin_id_to_sell"),
    6: .standard(proto: "coin_to_sell"),
    3: .standard(proto: "value_to_sell"),
    4: .standard(proto: "gas_price"),
    5: .same(proto: "height"),
    8: .standard(proto: "swap_from"),
    11: .same(proto: "route"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.buy != nil {try decoder.handleConflictingOneOf()}
          self.buy = .coinIDToBuy(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.sell != nil {try decoder.handleConflictingOneOf()}
          self.sell = .coinIDToSell(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.valueToSell) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.gasPrice) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sell != nil {try decoder.handleConflictingOneOf()}
          self.sell = .coinToSell(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.buy != nil {try decoder.handleConflictingOneOf()}
          self.buy = .coinToBuy(v)
        }
      }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.swapFrom) }()
      case 11: try { try decoder.decodeRepeatedUInt64Field(value: &self.route) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .coinIDToBuy(let v)? = self.buy {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if case .coinIDToSell(let v)? = self.sell {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.valueToSell.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToSell, fieldNumber: 3)
    }
    if self.gasPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasPrice, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 5)
    }
    try { if case .coinToSell(let v)? = self.sell {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if case .coinToBuy(let v)? = self.buy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if self.swapFrom != .optimal {
      try visitor.visitSingularEnumField(value: self.swapFrom, fieldNumber: 8)
    }
    if !self.route.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.route, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateCoinSellAllRequest, rhs: MinterEstimateCoinSellAllRequest) -> Bool {
    if lhs.buy != rhs.buy {return false}
    if lhs.sell != rhs.sell {return false}
    if lhs.valueToSell != rhs.valueToSell {return false}
    if lhs.gasPrice != rhs.gasPrice {return false}
    if lhs.height != rhs.height {return false}
    if lhs.swapFrom != rhs.swapFrom {return false}
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateCoinSellAllResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateCoinSellAllResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "will_get"),
    2: .standard(proto: "swap_from"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.willGet) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.swapFrom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.willGet.isEmpty {
      try visitor.visitSingularStringField(value: self.willGet, fieldNumber: 1)
    }
    if self.swapFrom != .optimal {
      try visitor.visitSingularEnumField(value: self.swapFrom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateCoinSellAllResponse, rhs: MinterEstimateCoinSellAllResponse) -> Bool {
    if lhs.willGet != rhs.willGet {return false}
    if lhs.swapFrom != rhs.swapFrom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateTxCommissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateTxCommissionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularStringField(value: self.tx, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateTxCommissionRequest, rhs: MinterEstimateTxCommissionRequest) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEstimateTxCommissionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateTxCommissionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commission"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commission) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commission.isEmpty {
      try visitor.visitSingularStringField(value: self.commission, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEstimateTxCommissionResponse, rhs: MinterEstimateTxCommissionResponse) -> Bool {
    if lhs.commission != rhs.commission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "search"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.search) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.search.isEmpty {
      try visitor.visitRepeatedStringField(value: self.search, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEventsRequest, rhs: MinterEventsRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.search != rhs.search {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEventsResponse, rhs: MinterEventsResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMissedBlocksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MissedBlocksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMissedBlocksRequest, rhs: MinterMissedBlocksRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMissedBlocksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MissedBlocksResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "missed_blocks"),
    2: .standard(proto: "missed_blocks_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.missedBlocks) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.missedBlocksCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.missedBlocks.isEmpty {
      try visitor.visitSingularStringField(value: self.missedBlocks, fieldNumber: 1)
    }
    if self.missedBlocksCount != 0 {
      try visitor.visitSingularInt64Field(value: self.missedBlocksCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMissedBlocksResponse, rhs: MinterMissedBlocksResponse) -> Bool {
    if lhs.missedBlocks != rhs.missedBlocks {return false}
    if lhs.missedBlocksCount != rhs.missedBlocksCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUnconfirmedTxsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnconfirmedTxsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_count"),
    2: .standard(proto: "total_transactions"),
    3: .standard(proto: "total_bytes"),
    4: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.transactionCount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalTransactions) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.totalBytes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.transactionCount, fieldNumber: 1)
    }
    if self.totalTransactions != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalTransactions, fieldNumber: 2)
    }
    if self.totalBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalBytes, fieldNumber: 3)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUnconfirmedTxsResponse, rhs: MinterUnconfirmedTxsResponse) -> Bool {
    if lhs.transactionCount != rhs.transactionCount {return false}
    if lhs.totalTransactions != rhs.totalTransactions {return false}
    if lhs.totalBytes != rhs.totalBytes {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUnconfirmedTxsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnconfirmedTxsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUnconfirmedTxsRequest, rhs: MinterUnconfirmedTxsRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterValidatorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterValidatorsRequest, rhs: MinterValidatorsRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterValidatorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "validators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterValidatorsResponse, rhs: MinterValidatorsResponse) -> Bool {
    if lhs.validators != rhs.validators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterValidatorsResponse.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterValidatorsResponse.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "voting_power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.votingPower) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if self.votingPower != 0 {
      try visitor.visitSingularUInt64Field(value: self.votingPower, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterValidatorsResponse.Result, rhs: MinterValidatorsResponse.Result) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSubscribeRequest, rhs: MinterSubscribeRequest) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSubscribeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .same(proto: "data"),
    3: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSubscribeResponse, rhs: MinterSubscribeResponse) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs._data != rhs._data {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSubscribeResponse.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterSubscribeResponse.protoMessageName + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedStringField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSubscribeResponse.Event, rhs: MinterSubscribeResponse.Event) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterHaltsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HaltsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterHaltsRequest, rhs: MinterHaltsRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterHaltsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HaltsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.publicKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.publicKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterHaltsResponse, rhs: MinterHaltsResponse) -> Bool {
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterFrozenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrozenRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "coin_id"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coinID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._coinID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterFrozenRequest, rhs: MinterFrozenRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._coinID != rhs._coinID {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterFrozenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrozenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frozen"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.frozen) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frozen.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frozen, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterFrozenResponse, rhs: MinterFrozenResponse) -> Bool {
    if lhs.frozen != rhs.frozen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterFrozenResponse.Frozen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterFrozenResponse.protoMessageName + ".Frozen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "address"),
    3: .standard(proto: "candidate_key"),
    4: .same(proto: "coin"),
    5: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.candidateKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.candidateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.candidateKey, fieldNumber: 3)
    }
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterFrozenResponse.Frozen, rhs: MinterFrozenResponse.Frozen) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.address != rhs.address {return false}
    if lhs.candidateKey != rhs.candidateKey {return false}
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterWaitListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "address"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterWaitListRequest, rhs: MinterWaitListRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.address != rhs.address {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterWaitListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterWaitListResponse, rhs: MinterWaitListResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterWaitListResponse.Wait: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MinterWaitListResponse.protoMessageName + ".Wait"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "public_key"),
    1: .same(proto: "coin"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterWaitListResponse.Wait, rhs: MinterWaitListResponse.Wait) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
