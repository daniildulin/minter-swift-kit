// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct MinterSendData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var to: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterSellCoinData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coinToSell: MinterCoin {
    get {return _coinToSell ?? MinterCoin()}
    set {_coinToSell = newValue}
  }
  /// Returns true if `coinToSell` has been explicitly set.
  public var hasCoinToSell: Bool {return self._coinToSell != nil}
  /// Clears the value of `coinToSell`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToSell() {self._coinToSell = nil}

  public var valueToSell: String = String()

  public var coinToBuy: MinterCoin {
    get {return _coinToBuy ?? MinterCoin()}
    set {_coinToBuy = newValue}
  }
  /// Returns true if `coinToBuy` has been explicitly set.
  public var hasCoinToBuy: Bool {return self._coinToBuy != nil}
  /// Clears the value of `coinToBuy`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToBuy() {self._coinToBuy = nil}

  public var minimumValueToBuy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coinToSell: MinterCoin? = nil
  fileprivate var _coinToBuy: MinterCoin? = nil
}

public struct MinterSellAllCoinData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coinToSell: MinterCoin {
    get {return _coinToSell ?? MinterCoin()}
    set {_coinToSell = newValue}
  }
  /// Returns true if `coinToSell` has been explicitly set.
  public var hasCoinToSell: Bool {return self._coinToSell != nil}
  /// Clears the value of `coinToSell`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToSell() {self._coinToSell = nil}

  public var coinToBuy: MinterCoin {
    get {return _coinToBuy ?? MinterCoin()}
    set {_coinToBuy = newValue}
  }
  /// Returns true if `coinToBuy` has been explicitly set.
  public var hasCoinToBuy: Bool {return self._coinToBuy != nil}
  /// Clears the value of `coinToBuy`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToBuy() {self._coinToBuy = nil}

  public var minimumValueToBuy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coinToSell: MinterCoin? = nil
  fileprivate var _coinToBuy: MinterCoin? = nil
}

public struct MinterBuyCoinData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coinToBuy: MinterCoin {
    get {return _coinToBuy ?? MinterCoin()}
    set {_coinToBuy = newValue}
  }
  /// Returns true if `coinToBuy` has been explicitly set.
  public var hasCoinToBuy: Bool {return self._coinToBuy != nil}
  /// Clears the value of `coinToBuy`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToBuy() {self._coinToBuy = nil}

  public var valueToBuy: String = String()

  public var coinToSell: MinterCoin {
    get {return _coinToSell ?? MinterCoin()}
    set {_coinToSell = newValue}
  }
  /// Returns true if `coinToSell` has been explicitly set.
  public var hasCoinToSell: Bool {return self._coinToSell != nil}
  /// Clears the value of `coinToSell`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToSell() {self._coinToSell = nil}

  public var maximumValueToSell: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coinToBuy: MinterCoin? = nil
  fileprivate var _coinToSell: MinterCoin? = nil
}

public struct MinterCreateCoinData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var symbol: String = String()

  public var initialAmount: String = String()

  public var initialReserve: String = String()

  public var constantReserveRatio: UInt64 = 0

  public var maxSupply: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterDeclareCandidacyData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var pubKey: String = String()

  public var commission: UInt64 = 0

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var stake: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterDelegateData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterUnbondData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterRedeemCheckData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawCheck: String = String()

  public var proof: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSetCandidateOnData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSetCandidateOffData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCreateMultisigData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threshold: UInt64 = 0

  public var weights: [UInt64] = []

  public var addresses: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterMultiSendData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: [MinterSendData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEditCandidateData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var rewardAddress: String = String()

  public var ownerAddress: String = String()

  public var controlAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSetHaltBlockData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterRecreateCoinData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var symbol: String = String()

  public var initialAmount: String = String()

  public var initialReserve: String = String()

  public var constantReserveRatio: UInt64 = 0

  public var maxSupply: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEditCoinOwnerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var symbol: String = String()

  public var newOwner: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEditMultisigData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threshold: UInt64 = 0

  public var weights: [UInt64] = []

  public var addresses: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEditCandidatePublicKeyData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var newPubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterCreateSwapPoolData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin0: MinterCoin {
    get {return _coin0 ?? MinterCoin()}
    set {_coin0 = newValue}
  }
  /// Returns true if `coin0` has been explicitly set.
  public var hasCoin0: Bool {return self._coin0 != nil}
  /// Clears the value of `coin0`. Subsequent reads from it will return its default value.
  public mutating func clearCoin0() {self._coin0 = nil}

  public var coin1: MinterCoin {
    get {return _coin1 ?? MinterCoin()}
    set {_coin1 = newValue}
  }
  /// Returns true if `coin1` has been explicitly set.
  public var hasCoin1: Bool {return self._coin1 != nil}
  /// Clears the value of `coin1`. Subsequent reads from it will return its default value.
  public mutating func clearCoin1() {self._coin1 = nil}

  public var volume0: String = String()

  public var volume1: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin0: MinterCoin? = nil
  fileprivate var _coin1: MinterCoin? = nil
}

public struct MinterAddLiquidityData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin0: MinterCoin {
    get {return _coin0 ?? MinterCoin()}
    set {_coin0 = newValue}
  }
  /// Returns true if `coin0` has been explicitly set.
  public var hasCoin0: Bool {return self._coin0 != nil}
  /// Clears the value of `coin0`. Subsequent reads from it will return its default value.
  public mutating func clearCoin0() {self._coin0 = nil}

  public var coin1: MinterCoin {
    get {return _coin1 ?? MinterCoin()}
    set {_coin1 = newValue}
  }
  /// Returns true if `coin1` has been explicitly set.
  public var hasCoin1: Bool {return self._coin1 != nil}
  /// Clears the value of `coin1`. Subsequent reads from it will return its default value.
  public mutating func clearCoin1() {self._coin1 = nil}

  public var volume0: String = String()

  public var maximumVolume1: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin0: MinterCoin? = nil
  fileprivate var _coin1: MinterCoin? = nil
}

public struct MinterRemoveLiquidityData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin0: MinterCoin {
    get {return _coin0 ?? MinterCoin()}
    set {_coin0 = newValue}
  }
  /// Returns true if `coin0` has been explicitly set.
  public var hasCoin0: Bool {return self._coin0 != nil}
  /// Clears the value of `coin0`. Subsequent reads from it will return its default value.
  public mutating func clearCoin0() {self._coin0 = nil}

  public var coin1: MinterCoin {
    get {return _coin1 ?? MinterCoin()}
    set {_coin1 = newValue}
  }
  /// Returns true if `coin1` has been explicitly set.
  public var hasCoin1: Bool {return self._coin1 != nil}
  /// Clears the value of `coin1`. Subsequent reads from it will return its default value.
  public mutating func clearCoin1() {self._coin1 = nil}

  public var liquidity: String = String()

  public var minimumVolume0: String = String()

  public var minimumVolume1: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin0: MinterCoin? = nil
  fileprivate var _coin1: MinterCoin? = nil
}

public struct MinterSellSwapPoolData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coins: [MinterCoin] = []

  public var valueToSell: String = String()

  public var minimumValueToBuy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterSellAllSwapPoolData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coins: [MinterCoin] = []

  public var minimumValueToBuy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterBuySwapPoolData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coins: [MinterCoin] = []

  public var valueToBuy: String = String()

  public var maximumValueToSell: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterEditCandidateCommission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var commission: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterMintTokenData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterBurnTokenData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: MinterCoin {
    get {return _coin ?? MinterCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: MinterCoin? = nil
}

public struct MinterCreateTokenData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var symbol: String = String()

  public var initialAmount: String = String()

  public var maxSupply: String = String()

  public var mintable: Bool = false

  public var burnable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterRecreateTokenData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var symbol: String = String()

  public var initialAmount: String = String()

  public var maxSupply: String = String()

  public var mintable: Bool = false

  public var burnable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterVoteCommissionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String {
    get {return _storage._pubKey}
    set {_uniqueStorage()._pubKey = newValue}
  }

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var coin: MinterCoin {
    get {return _storage._coin ?? MinterCoin()}
    set {_uniqueStorage()._coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return _storage._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {_uniqueStorage()._coin = nil}

  public var payloadByte: String {
    get {return _storage._payloadByte}
    set {_uniqueStorage()._payloadByte = newValue}
  }

  public var send: String {
    get {return _storage._send}
    set {_uniqueStorage()._send = newValue}
  }

  public var buyBancor: String {
    get {return _storage._buyBancor}
    set {_uniqueStorage()._buyBancor = newValue}
  }

  public var sellBancor: String {
    get {return _storage._sellBancor}
    set {_uniqueStorage()._sellBancor = newValue}
  }

  public var sellAllBancor: String {
    get {return _storage._sellAllBancor}
    set {_uniqueStorage()._sellAllBancor = newValue}
  }

  public var buyPoolBase: String {
    get {return _storage._buyPoolBase}
    set {_uniqueStorage()._buyPoolBase = newValue}
  }

  public var buyPoolDelta: String {
    get {return _storage._buyPoolDelta}
    set {_uniqueStorage()._buyPoolDelta = newValue}
  }

  public var sellPoolBase: String {
    get {return _storage._sellPoolBase}
    set {_uniqueStorage()._sellPoolBase = newValue}
  }

  public var sellPoolDelta: String {
    get {return _storage._sellPoolDelta}
    set {_uniqueStorage()._sellPoolDelta = newValue}
  }

  public var sellAllPoolBase: String {
    get {return _storage._sellAllPoolBase}
    set {_uniqueStorage()._sellAllPoolBase = newValue}
  }

  public var sellAllPoolDelta: String {
    get {return _storage._sellAllPoolDelta}
    set {_uniqueStorage()._sellAllPoolDelta = newValue}
  }

  public var createTicker3: String {
    get {return _storage._createTicker3}
    set {_uniqueStorage()._createTicker3 = newValue}
  }

  public var createTicker4: String {
    get {return _storage._createTicker4}
    set {_uniqueStorage()._createTicker4 = newValue}
  }

  public var createTicker5: String {
    get {return _storage._createTicker5}
    set {_uniqueStorage()._createTicker5 = newValue}
  }

  public var createTicker6: String {
    get {return _storage._createTicker6}
    set {_uniqueStorage()._createTicker6 = newValue}
  }

  public var createTicker710: String {
    get {return _storage._createTicker710}
    set {_uniqueStorage()._createTicker710 = newValue}
  }

  public var createCoin: String {
    get {return _storage._createCoin}
    set {_uniqueStorage()._createCoin = newValue}
  }

  public var createToken: String {
    get {return _storage._createToken}
    set {_uniqueStorage()._createToken = newValue}
  }

  public var recreateCoin: String {
    get {return _storage._recreateCoin}
    set {_uniqueStorage()._recreateCoin = newValue}
  }

  public var recreateToken: String {
    get {return _storage._recreateToken}
    set {_uniqueStorage()._recreateToken = newValue}
  }

  public var declareCandidacy: String {
    get {return _storage._declareCandidacy}
    set {_uniqueStorage()._declareCandidacy = newValue}
  }

  public var delegate: String {
    get {return _storage._delegate}
    set {_uniqueStorage()._delegate = newValue}
  }

  public var unbond: String {
    get {return _storage._unbond}
    set {_uniqueStorage()._unbond = newValue}
  }

  public var redeemCheck: String {
    get {return _storage._redeemCheck}
    set {_uniqueStorage()._redeemCheck = newValue}
  }

  public var setCandidateOn: String {
    get {return _storage._setCandidateOn}
    set {_uniqueStorage()._setCandidateOn = newValue}
  }

  public var setCandidateOff: String {
    get {return _storage._setCandidateOff}
    set {_uniqueStorage()._setCandidateOff = newValue}
  }

  public var createMultisig: String {
    get {return _storage._createMultisig}
    set {_uniqueStorage()._createMultisig = newValue}
  }

  public var multisendBase: String {
    get {return _storage._multisendBase}
    set {_uniqueStorage()._multisendBase = newValue}
  }

  public var multisendDelta: String {
    get {return _storage._multisendDelta}
    set {_uniqueStorage()._multisendDelta = newValue}
  }

  public var editCandidate: String {
    get {return _storage._editCandidate}
    set {_uniqueStorage()._editCandidate = newValue}
  }

  public var setHaltBlock: String {
    get {return _storage._setHaltBlock}
    set {_uniqueStorage()._setHaltBlock = newValue}
  }

  public var editTickerOwner: String {
    get {return _storage._editTickerOwner}
    set {_uniqueStorage()._editTickerOwner = newValue}
  }

  public var editMultisig: String {
    get {return _storage._editMultisig}
    set {_uniqueStorage()._editMultisig = newValue}
  }

  public var editCandidatePublicKey: String {
    get {return _storage._editCandidatePublicKey}
    set {_uniqueStorage()._editCandidatePublicKey = newValue}
  }

  public var createSwapPool: String {
    get {return _storage._createSwapPool}
    set {_uniqueStorage()._createSwapPool = newValue}
  }

  public var addLiquidity: String {
    get {return _storage._addLiquidity}
    set {_uniqueStorage()._addLiquidity = newValue}
  }

  public var removeLiquidity: String {
    get {return _storage._removeLiquidity}
    set {_uniqueStorage()._removeLiquidity = newValue}
  }

  public var editCandidateCommission: String {
    get {return _storage._editCandidateCommission}
    set {_uniqueStorage()._editCandidateCommission = newValue}
  }

  public var mintToken: String {
    get {return _storage._mintToken}
    set {_uniqueStorage()._mintToken = newValue}
  }

  public var burnToken: String {
    get {return _storage._burnToken}
    set {_uniqueStorage()._burnToken = newValue}
  }

  public var voteCommission: String {
    get {return _storage._voteCommission}
    set {_uniqueStorage()._voteCommission = newValue}
  }

  public var voteUpdate: String {
    get {return _storage._voteUpdate}
    set {_uniqueStorage()._voteUpdate = newValue}
  }

  public var failedTx: String {
    get {return _storage._failedTx}
    set {_uniqueStorage()._failedTx = newValue}
  }

  public var addLimitOrder: String {
    get {return _storage._addLimitOrder}
    set {_uniqueStorage()._addLimitOrder = newValue}
  }

  public var removeLimitOrder: String {
    get {return _storage._removeLimitOrder}
    set {_uniqueStorage()._removeLimitOrder = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MinterVoteUpdateData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: String = String()

  public var height: UInt64 = 0

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterAddLimitOrderData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coinToSell: MinterCoin {
    get {return _coinToSell ?? MinterCoin()}
    set {_coinToSell = newValue}
  }
  /// Returns true if `coinToSell` has been explicitly set.
  public var hasCoinToSell: Bool {return self._coinToSell != nil}
  /// Clears the value of `coinToSell`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToSell() {self._coinToSell = nil}

  public var valueToSell: String = String()

  public var coinToBuy: MinterCoin {
    get {return _coinToBuy ?? MinterCoin()}
    set {_coinToBuy = newValue}
  }
  /// Returns true if `coinToBuy` has been explicitly set.
  public var hasCoinToBuy: Bool {return self._coinToBuy != nil}
  /// Clears the value of `coinToBuy`. Subsequent reads from it will return its default value.
  public mutating func clearCoinToBuy() {self._coinToBuy = nil}

  public var valueToBuy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coinToSell: MinterCoin? = nil
  fileprivate var _coinToBuy: MinterCoin? = nil
}

public struct MinterRemoveLimitOrderData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api_pb"

extension MinterSendData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .same(proto: "to"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSendData, rhs: MinterSendData) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.to != rhs.to {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSellCoinData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SellCoinData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_to_sell"),
    2: .standard(proto: "value_to_sell"),
    3: .standard(proto: "coin_to_buy"),
    4: .standard(proto: "minimum_value_to_buy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coinToSell) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.valueToSell) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._coinToBuy) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.minimumValueToBuy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coinToSell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.valueToSell.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToSell, fieldNumber: 2)
    }
    try { if let v = self._coinToBuy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.minimumValueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumValueToBuy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSellCoinData, rhs: MinterSellCoinData) -> Bool {
    if lhs._coinToSell != rhs._coinToSell {return false}
    if lhs.valueToSell != rhs.valueToSell {return false}
    if lhs._coinToBuy != rhs._coinToBuy {return false}
    if lhs.minimumValueToBuy != rhs.minimumValueToBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSellAllCoinData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SellAllCoinData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_to_sell"),
    2: .standard(proto: "coin_to_buy"),
    3: .standard(proto: "minimum_value_to_buy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coinToSell) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coinToBuy) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minimumValueToBuy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coinToSell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coinToBuy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.minimumValueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumValueToBuy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSellAllCoinData, rhs: MinterSellAllCoinData) -> Bool {
    if lhs._coinToSell != rhs._coinToSell {return false}
    if lhs._coinToBuy != rhs._coinToBuy {return false}
    if lhs.minimumValueToBuy != rhs.minimumValueToBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBuyCoinData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuyCoinData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_to_buy"),
    2: .standard(proto: "value_to_buy"),
    3: .standard(proto: "coin_to_sell"),
    4: .standard(proto: "maximum_value_to_sell"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coinToBuy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.valueToBuy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._coinToSell) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.maximumValueToSell) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coinToBuy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.valueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToBuy, fieldNumber: 2)
    }
    try { if let v = self._coinToSell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.maximumValueToSell.isEmpty {
      try visitor.visitSingularStringField(value: self.maximumValueToSell, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBuyCoinData, rhs: MinterBuyCoinData) -> Bool {
    if lhs._coinToBuy != rhs._coinToBuy {return false}
    if lhs.valueToBuy != rhs.valueToBuy {return false}
    if lhs._coinToSell != rhs._coinToSell {return false}
    if lhs.maximumValueToSell != rhs.maximumValueToSell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCreateCoinData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateCoinData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .standard(proto: "initial_amount"),
    4: .standard(proto: "initial_reserve"),
    5: .standard(proto: "constant_reserve_ratio"),
    6: .standard(proto: "max_supply"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.initialAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.initialReserve) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.constantReserveRatio) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.maxSupply) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.initialAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.initialAmount, fieldNumber: 3)
    }
    if !self.initialReserve.isEmpty {
      try visitor.visitSingularStringField(value: self.initialReserve, fieldNumber: 4)
    }
    if self.constantReserveRatio != 0 {
      try visitor.visitSingularUInt64Field(value: self.constantReserveRatio, fieldNumber: 5)
    }
    if !self.maxSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSupply, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCreateCoinData, rhs: MinterCreateCoinData) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.initialAmount != rhs.initialAmount {return false}
    if lhs.initialReserve != rhs.initialReserve {return false}
    if lhs.constantReserveRatio != rhs.constantReserveRatio {return false}
    if lhs.maxSupply != rhs.maxSupply {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterDeclareCandidacyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeclareCandidacyData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "pub_key"),
    3: .same(proto: "commission"),
    4: .same(proto: "coin"),
    5: .same(proto: "stake"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.commission) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.stake) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 2)
    }
    if self.commission != 0 {
      try visitor.visitSingularUInt64Field(value: self.commission, fieldNumber: 3)
    }
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.stake.isEmpty {
      try visitor.visitSingularStringField(value: self.stake, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterDeclareCandidacyData, rhs: MinterDeclareCandidacyData) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs._coin != rhs._coin {return false}
    if lhs.stake != rhs.stake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterDelegateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "coin"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterDelegateData, rhs: MinterDelegateData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUnbondData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnbondData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "coin"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUnbondData, rhs: MinterUnbondData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRedeemCheckData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedeemCheckData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_check"),
    2: .same(proto: "proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rawCheck) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawCheck.isEmpty {
      try visitor.visitSingularStringField(value: self.rawCheck, fieldNumber: 1)
    }
    if !self.proof.isEmpty {
      try visitor.visitSingularStringField(value: self.proof, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterRedeemCheckData, rhs: MinterRedeemCheckData) -> Bool {
    if lhs.rawCheck != rhs.rawCheck {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSetCandidateOnData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCandidateOnData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSetCandidateOnData, rhs: MinterSetCandidateOnData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSetCandidateOffData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCandidateOffData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSetCandidateOffData, rhs: MinterSetCandidateOffData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCreateMultisigData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateMultisigData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "weights"),
    3: .same(proto: "addresses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.weights) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularUInt64Field(value: self.threshold, fieldNumber: 1)
    }
    if !self.weights.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.weights, fieldNumber: 2)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCreateMultisigData, rhs: MinterCreateMultisigData) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.weights != rhs.weights {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMultiSendData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiSendData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMultiSendData, rhs: MinterMultiSendData) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEditCandidateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditCandidateData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    3: .standard(proto: "reward_address"),
    4: .standard(proto: "owner_address"),
    5: .standard(proto: "control_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rewardAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.controlAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.rewardAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAddress, fieldNumber: 3)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 4)
    }
    if !self.controlAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.controlAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEditCandidateData, rhs: MinterEditCandidateData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.rewardAddress != rhs.rewardAddress {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.controlAddress != rhs.controlAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSetHaltBlockData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetHaltBlockData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSetHaltBlockData, rhs: MinterSetHaltBlockData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRecreateCoinData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecreateCoinData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .standard(proto: "initial_amount"),
    4: .standard(proto: "initial_reserve"),
    5: .standard(proto: "constant_reserve_ratio"),
    6: .standard(proto: "max_supply"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.initialAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.initialReserve) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.constantReserveRatio) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.maxSupply) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.initialAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.initialAmount, fieldNumber: 3)
    }
    if !self.initialReserve.isEmpty {
      try visitor.visitSingularStringField(value: self.initialReserve, fieldNumber: 4)
    }
    if self.constantReserveRatio != 0 {
      try visitor.visitSingularUInt64Field(value: self.constantReserveRatio, fieldNumber: 5)
    }
    if !self.maxSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSupply, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterRecreateCoinData, rhs: MinterRecreateCoinData) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.initialAmount != rhs.initialAmount {return false}
    if lhs.initialReserve != rhs.initialReserve {return false}
    if lhs.constantReserveRatio != rhs.constantReserveRatio {return false}
    if lhs.maxSupply != rhs.maxSupply {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEditCoinOwnerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditCoinOwnerData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .standard(proto: "new_owner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newOwner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if !self.newOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.newOwner, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEditCoinOwnerData, rhs: MinterEditCoinOwnerData) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.newOwner != rhs.newOwner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEditMultisigData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditMultisigData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "weights"),
    3: .same(proto: "addresses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.weights) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularUInt64Field(value: self.threshold, fieldNumber: 1)
    }
    if !self.weights.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.weights, fieldNumber: 2)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEditMultisigData, rhs: MinterEditMultisigData) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.weights != rhs.weights {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEditCandidatePublicKeyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditCandidatePublicKeyData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .standard(proto: "new_pub_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newPubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.newPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.newPubKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEditCandidatePublicKeyData, rhs: MinterEditCandidatePublicKeyData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.newPubKey != rhs.newPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCreateSwapPoolData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateSwapPoolData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin0"),
    2: .same(proto: "coin1"),
    3: .same(proto: "volume0"),
    4: .same(proto: "volume1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin0) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coin1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.volume0) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.volume1) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coin1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.volume0.isEmpty {
      try visitor.visitSingularStringField(value: self.volume0, fieldNumber: 3)
    }
    if !self.volume1.isEmpty {
      try visitor.visitSingularStringField(value: self.volume1, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCreateSwapPoolData, rhs: MinterCreateSwapPoolData) -> Bool {
    if lhs._coin0 != rhs._coin0 {return false}
    if lhs._coin1 != rhs._coin1 {return false}
    if lhs.volume0 != rhs.volume0 {return false}
    if lhs.volume1 != rhs.volume1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddLiquidityData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddLiquidityData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin0"),
    2: .same(proto: "coin1"),
    3: .same(proto: "volume0"),
    4: .standard(proto: "maximum_volume1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin0) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coin1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.volume0) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.maximumVolume1) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coin1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.volume0.isEmpty {
      try visitor.visitSingularStringField(value: self.volume0, fieldNumber: 3)
    }
    if !self.maximumVolume1.isEmpty {
      try visitor.visitSingularStringField(value: self.maximumVolume1, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddLiquidityData, rhs: MinterAddLiquidityData) -> Bool {
    if lhs._coin0 != rhs._coin0 {return false}
    if lhs._coin1 != rhs._coin1 {return false}
    if lhs.volume0 != rhs.volume0 {return false}
    if lhs.maximumVolume1 != rhs.maximumVolume1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRemoveLiquidityData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveLiquidityData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin0"),
    2: .same(proto: "coin1"),
    3: .same(proto: "liquidity"),
    4: .standard(proto: "minimum_volume0"),
    5: .standard(proto: "minimum_volume1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin0) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coin1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.liquidity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.minimumVolume0) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minimumVolume1) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coin1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.liquidity.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidity, fieldNumber: 3)
    }
    if !self.minimumVolume0.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumVolume0, fieldNumber: 4)
    }
    if !self.minimumVolume1.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumVolume1, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterRemoveLiquidityData, rhs: MinterRemoveLiquidityData) -> Bool {
    if lhs._coin0 != rhs._coin0 {return false}
    if lhs._coin1 != rhs._coin1 {return false}
    if lhs.liquidity != rhs.liquidity {return false}
    if lhs.minimumVolume0 != rhs.minimumVolume0 {return false}
    if lhs.minimumVolume1 != rhs.minimumVolume1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSellSwapPoolData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SellSwapPoolData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coins"),
    2: .standard(proto: "value_to_sell"),
    4: .standard(proto: "minimum_value_to_buy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.coins) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.valueToSell) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.minimumValueToBuy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 1)
    }
    if !self.valueToSell.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToSell, fieldNumber: 2)
    }
    if !self.minimumValueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumValueToBuy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSellSwapPoolData, rhs: MinterSellSwapPoolData) -> Bool {
    if lhs.coins != rhs.coins {return false}
    if lhs.valueToSell != rhs.valueToSell {return false}
    if lhs.minimumValueToBuy != rhs.minimumValueToBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterSellAllSwapPoolData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SellAllSwapPoolData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coins"),
    3: .standard(proto: "minimum_value_to_buy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.coins) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minimumValueToBuy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 1)
    }
    if !self.minimumValueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumValueToBuy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSellAllSwapPoolData, rhs: MinterSellAllSwapPoolData) -> Bool {
    if lhs.coins != rhs.coins {return false}
    if lhs.minimumValueToBuy != rhs.minimumValueToBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBuySwapPoolData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuySwapPoolData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coins"),
    2: .standard(proto: "value_to_buy"),
    4: .standard(proto: "maximum_value_to_sell"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.coins) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.valueToBuy) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.maximumValueToSell) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 1)
    }
    if !self.valueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToBuy, fieldNumber: 2)
    }
    if !self.maximumValueToSell.isEmpty {
      try visitor.visitSingularStringField(value: self.maximumValueToSell, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBuySwapPoolData, rhs: MinterBuySwapPoolData) -> Bool {
    if lhs.coins != rhs.coins {return false}
    if lhs.valueToBuy != rhs.valueToBuy {return false}
    if lhs.maximumValueToSell != rhs.maximumValueToSell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterEditCandidateCommission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditCandidateCommission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "commission"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.commission) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.commission != 0 {
      try visitor.visitSingularUInt64Field(value: self.commission, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterEditCandidateCommission, rhs: MinterEditCandidateCommission) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterMintTokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MintTokenData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterMintTokenData, rhs: MinterMintTokenData) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterBurnTokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BurnTokenData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterBurnTokenData, rhs: MinterBurnTokenData) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterCreateTokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTokenData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .standard(proto: "initial_amount"),
    4: .standard(proto: "max_supply"),
    5: .same(proto: "mintable"),
    6: .same(proto: "burnable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.initialAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.maxSupply) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.mintable) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.burnable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.initialAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.initialAmount, fieldNumber: 3)
    }
    if !self.maxSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSupply, fieldNumber: 4)
    }
    if self.mintable != false {
      try visitor.visitSingularBoolField(value: self.mintable, fieldNumber: 5)
    }
    if self.burnable != false {
      try visitor.visitSingularBoolField(value: self.burnable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterCreateTokenData, rhs: MinterCreateTokenData) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.initialAmount != rhs.initialAmount {return false}
    if lhs.maxSupply != rhs.maxSupply {return false}
    if lhs.mintable != rhs.mintable {return false}
    if lhs.burnable != rhs.burnable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRecreateTokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecreateTokenData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .standard(proto: "initial_amount"),
    4: .standard(proto: "max_supply"),
    5: .same(proto: "mintable"),
    6: .same(proto: "burnable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.initialAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.maxSupply) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.mintable) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.burnable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.initialAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.initialAmount, fieldNumber: 3)
    }
    if !self.maxSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSupply, fieldNumber: 4)
    }
    if self.mintable != false {
      try visitor.visitSingularBoolField(value: self.mintable, fieldNumber: 5)
    }
    if self.burnable != false {
      try visitor.visitSingularBoolField(value: self.burnable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterRecreateTokenData, rhs: MinterRecreateTokenData) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.initialAmount != rhs.initialAmount {return false}
    if lhs.maxSupply != rhs.maxSupply {return false}
    if lhs.mintable != rhs.mintable {return false}
    if lhs.burnable != rhs.burnable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterVoteCommissionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoteCommissionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "height"),
    3: .same(proto: "coin"),
    4: .standard(proto: "payload_byte"),
    5: .same(proto: "send"),
    38: .standard(proto: "buy_bancor"),
    39: .standard(proto: "sell_bancor"),
    40: .standard(proto: "sell_all_bancor"),
    41: .standard(proto: "buy_pool_base"),
    53: .standard(proto: "buy_pool_delta"),
    42: .standard(proto: "sell_pool_base"),
    54: .standard(proto: "sell_pool_delta"),
    43: .standard(proto: "sell_all_pool_base"),
    55: .standard(proto: "sell_all_pool_delta"),
    7: .standard(proto: "create_ticker3"),
    8: .standard(proto: "create_ticker4"),
    9: .standard(proto: "create_ticker5"),
    10: .standard(proto: "create_ticker6"),
    11: .standard(proto: "create_ticker7_10"),
    34: .standard(proto: "create_coin"),
    35: .standard(proto: "create_token"),
    36: .standard(proto: "recreate_coin"),
    37: .standard(proto: "recreate_token"),
    13: .standard(proto: "declare_candidacy"),
    14: .same(proto: "delegate"),
    15: .same(proto: "unbond"),
    16: .standard(proto: "redeem_check"),
    44: .standard(proto: "set_candidate_on"),
    45: .standard(proto: "set_candidate_off"),
    18: .standard(proto: "create_multisig"),
    51: .standard(proto: "multisend_base"),
    52: .standard(proto: "multisend_delta"),
    20: .standard(proto: "edit_candidate"),
    21: .standard(proto: "set_halt_block"),
    22: .standard(proto: "edit_ticker_owner"),
    23: .standard(proto: "edit_multisig"),
    25: .standard(proto: "edit_candidate_public_key"),
    48: .standard(proto: "create_swap_pool"),
    49: .standard(proto: "add_liquidity"),
    50: .standard(proto: "remove_liquidity"),
    28: .standard(proto: "edit_candidate_commission"),
    46: .standard(proto: "mint_token"),
    47: .standard(proto: "burn_token"),
    31: .standard(proto: "vote_commission"),
    32: .standard(proto: "vote_update"),
    56: .standard(proto: "failed_tx"),
    57: .standard(proto: "add_limit_order"),
    58: .standard(proto: "remove_limit_order"),
  ]

  fileprivate class _StorageClass {
    var _pubKey: String = String()
    var _height: UInt64 = 0
    var _coin: MinterCoin? = nil
    var _payloadByte: String = String()
    var _send: String = String()
    var _buyBancor: String = String()
    var _sellBancor: String = String()
    var _sellAllBancor: String = String()
    var _buyPoolBase: String = String()
    var _buyPoolDelta: String = String()
    var _sellPoolBase: String = String()
    var _sellPoolDelta: String = String()
    var _sellAllPoolBase: String = String()
    var _sellAllPoolDelta: String = String()
    var _createTicker3: String = String()
    var _createTicker4: String = String()
    var _createTicker5: String = String()
    var _createTicker6: String = String()
    var _createTicker710: String = String()
    var _createCoin: String = String()
    var _createToken: String = String()
    var _recreateCoin: String = String()
    var _recreateToken: String = String()
    var _declareCandidacy: String = String()
    var _delegate: String = String()
    var _unbond: String = String()
    var _redeemCheck: String = String()
    var _setCandidateOn: String = String()
    var _setCandidateOff: String = String()
    var _createMultisig: String = String()
    var _multisendBase: String = String()
    var _multisendDelta: String = String()
    var _editCandidate: String = String()
    var _setHaltBlock: String = String()
    var _editTickerOwner: String = String()
    var _editMultisig: String = String()
    var _editCandidatePublicKey: String = String()
    var _createSwapPool: String = String()
    var _addLiquidity: String = String()
    var _removeLiquidity: String = String()
    var _editCandidateCommission: String = String()
    var _mintToken: String = String()
    var _burnToken: String = String()
    var _voteCommission: String = String()
    var _voteUpdate: String = String()
    var _failedTx: String = String()
    var _addLimitOrder: String = String()
    var _removeLimitOrder: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pubKey = source._pubKey
      _height = source._height
      _coin = source._coin
      _payloadByte = source._payloadByte
      _send = source._send
      _buyBancor = source._buyBancor
      _sellBancor = source._sellBancor
      _sellAllBancor = source._sellAllBancor
      _buyPoolBase = source._buyPoolBase
      _buyPoolDelta = source._buyPoolDelta
      _sellPoolBase = source._sellPoolBase
      _sellPoolDelta = source._sellPoolDelta
      _sellAllPoolBase = source._sellAllPoolBase
      _sellAllPoolDelta = source._sellAllPoolDelta
      _createTicker3 = source._createTicker3
      _createTicker4 = source._createTicker4
      _createTicker5 = source._createTicker5
      _createTicker6 = source._createTicker6
      _createTicker710 = source._createTicker710
      _createCoin = source._createCoin
      _createToken = source._createToken
      _recreateCoin = source._recreateCoin
      _recreateToken = source._recreateToken
      _declareCandidacy = source._declareCandidacy
      _delegate = source._delegate
      _unbond = source._unbond
      _redeemCheck = source._redeemCheck
      _setCandidateOn = source._setCandidateOn
      _setCandidateOff = source._setCandidateOff
      _createMultisig = source._createMultisig
      _multisendBase = source._multisendBase
      _multisendDelta = source._multisendDelta
      _editCandidate = source._editCandidate
      _setHaltBlock = source._setHaltBlock
      _editTickerOwner = source._editTickerOwner
      _editMultisig = source._editMultisig
      _editCandidatePublicKey = source._editCandidatePublicKey
      _createSwapPool = source._createSwapPool
      _addLiquidity = source._addLiquidity
      _removeLiquidity = source._removeLiquidity
      _editCandidateCommission = source._editCandidateCommission
      _mintToken = source._mintToken
      _burnToken = source._burnToken
      _voteCommission = source._voteCommission
      _voteUpdate = source._voteUpdate
      _failedTx = source._failedTx
      _addLimitOrder = source._addLimitOrder
      _removeLimitOrder = source._removeLimitOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._pubKey) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._height) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._coin) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._payloadByte) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._send) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._createTicker3) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._createTicker4) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._createTicker5) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._createTicker6) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._createTicker710) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._declareCandidacy) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._delegate) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._unbond) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._redeemCheck) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._createMultisig) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._editCandidate) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._setHaltBlock) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._editTickerOwner) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._editMultisig) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._editCandidatePublicKey) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._editCandidateCommission) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._voteCommission) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._voteUpdate) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._createCoin) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._createToken) }()
        case 36: try { try decoder.decodeSingularStringField(value: &_storage._recreateCoin) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._recreateToken) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._buyBancor) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._sellBancor) }()
        case 40: try { try decoder.decodeSingularStringField(value: &_storage._sellAllBancor) }()
        case 41: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolBase) }()
        case 42: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolBase) }()
        case 43: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolBase) }()
        case 44: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOn) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOff) }()
        case 46: try { try decoder.decodeSingularStringField(value: &_storage._mintToken) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._burnToken) }()
        case 48: try { try decoder.decodeSingularStringField(value: &_storage._createSwapPool) }()
        case 49: try { try decoder.decodeSingularStringField(value: &_storage._addLiquidity) }()
        case 50: try { try decoder.decodeSingularStringField(value: &_storage._removeLiquidity) }()
        case 51: try { try decoder.decodeSingularStringField(value: &_storage._multisendBase) }()
        case 52: try { try decoder.decodeSingularStringField(value: &_storage._multisendDelta) }()
        case 53: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolDelta) }()
        case 54: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolDelta) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolDelta) }()
        case 56: try { try decoder.decodeSingularStringField(value: &_storage._failedTx) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._addLimitOrder) }()
        case 58: try { try decoder.decodeSingularStringField(value: &_storage._removeLimitOrder) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._pubKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pubKey, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 2)
      }
      try { if let v = _storage._coin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._payloadByte.isEmpty {
        try visitor.visitSingularStringField(value: _storage._payloadByte, fieldNumber: 4)
      }
      if !_storage._send.isEmpty {
        try visitor.visitSingularStringField(value: _storage._send, fieldNumber: 5)
      }
      if !_storage._createTicker3.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker3, fieldNumber: 7)
      }
      if !_storage._createTicker4.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker4, fieldNumber: 8)
      }
      if !_storage._createTicker5.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker5, fieldNumber: 9)
      }
      if !_storage._createTicker6.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker6, fieldNumber: 10)
      }
      if !_storage._createTicker710.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker710, fieldNumber: 11)
      }
      if !_storage._declareCandidacy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._declareCandidacy, fieldNumber: 13)
      }
      if !_storage._delegate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegate, fieldNumber: 14)
      }
      if !_storage._unbond.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unbond, fieldNumber: 15)
      }
      if !_storage._redeemCheck.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redeemCheck, fieldNumber: 16)
      }
      if !_storage._createMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createMultisig, fieldNumber: 18)
      }
      if !_storage._editCandidate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidate, fieldNumber: 20)
      }
      if !_storage._setHaltBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setHaltBlock, fieldNumber: 21)
      }
      if !_storage._editTickerOwner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editTickerOwner, fieldNumber: 22)
      }
      if !_storage._editMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editMultisig, fieldNumber: 23)
      }
      if !_storage._editCandidatePublicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidatePublicKey, fieldNumber: 25)
      }
      if !_storage._editCandidateCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidateCommission, fieldNumber: 28)
      }
      if !_storage._voteCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteCommission, fieldNumber: 31)
      }
      if !_storage._voteUpdate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteUpdate, fieldNumber: 32)
      }
      if !_storage._createCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createCoin, fieldNumber: 34)
      }
      if !_storage._createToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createToken, fieldNumber: 35)
      }
      if !_storage._recreateCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateCoin, fieldNumber: 36)
      }
      if !_storage._recreateToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateToken, fieldNumber: 37)
      }
      if !_storage._buyBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyBancor, fieldNumber: 38)
      }
      if !_storage._sellBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellBancor, fieldNumber: 39)
      }
      if !_storage._sellAllBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllBancor, fieldNumber: 40)
      }
      if !_storage._buyPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolBase, fieldNumber: 41)
      }
      if !_storage._sellPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolBase, fieldNumber: 42)
      }
      if !_storage._sellAllPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolBase, fieldNumber: 43)
      }
      if !_storage._setCandidateOn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOn, fieldNumber: 44)
      }
      if !_storage._setCandidateOff.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOff, fieldNumber: 45)
      }
      if !_storage._mintToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mintToken, fieldNumber: 46)
      }
      if !_storage._burnToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._burnToken, fieldNumber: 47)
      }
      if !_storage._createSwapPool.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createSwapPool, fieldNumber: 48)
      }
      if !_storage._addLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLiquidity, fieldNumber: 49)
      }
      if !_storage._removeLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLiquidity, fieldNumber: 50)
      }
      if !_storage._multisendBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendBase, fieldNumber: 51)
      }
      if !_storage._multisendDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendDelta, fieldNumber: 52)
      }
      if !_storage._buyPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolDelta, fieldNumber: 53)
      }
      if !_storage._sellPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolDelta, fieldNumber: 54)
      }
      if !_storage._sellAllPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolDelta, fieldNumber: 55)
      }
      if !_storage._failedTx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._failedTx, fieldNumber: 56)
      }
      if !_storage._addLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLimitOrder, fieldNumber: 57)
      }
      if !_storage._removeLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLimitOrder, fieldNumber: 58)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterVoteCommissionData, rhs: MinterVoteCommissionData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pubKey != rhs_storage._pubKey {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._coin != rhs_storage._coin {return false}
        if _storage._payloadByte != rhs_storage._payloadByte {return false}
        if _storage._send != rhs_storage._send {return false}
        if _storage._buyBancor != rhs_storage._buyBancor {return false}
        if _storage._sellBancor != rhs_storage._sellBancor {return false}
        if _storage._sellAllBancor != rhs_storage._sellAllBancor {return false}
        if _storage._buyPoolBase != rhs_storage._buyPoolBase {return false}
        if _storage._buyPoolDelta != rhs_storage._buyPoolDelta {return false}
        if _storage._sellPoolBase != rhs_storage._sellPoolBase {return false}
        if _storage._sellPoolDelta != rhs_storage._sellPoolDelta {return false}
        if _storage._sellAllPoolBase != rhs_storage._sellAllPoolBase {return false}
        if _storage._sellAllPoolDelta != rhs_storage._sellAllPoolDelta {return false}
        if _storage._createTicker3 != rhs_storage._createTicker3 {return false}
        if _storage._createTicker4 != rhs_storage._createTicker4 {return false}
        if _storage._createTicker5 != rhs_storage._createTicker5 {return false}
        if _storage._createTicker6 != rhs_storage._createTicker6 {return false}
        if _storage._createTicker710 != rhs_storage._createTicker710 {return false}
        if _storage._createCoin != rhs_storage._createCoin {return false}
        if _storage._createToken != rhs_storage._createToken {return false}
        if _storage._recreateCoin != rhs_storage._recreateCoin {return false}
        if _storage._recreateToken != rhs_storage._recreateToken {return false}
        if _storage._declareCandidacy != rhs_storage._declareCandidacy {return false}
        if _storage._delegate != rhs_storage._delegate {return false}
        if _storage._unbond != rhs_storage._unbond {return false}
        if _storage._redeemCheck != rhs_storage._redeemCheck {return false}
        if _storage._setCandidateOn != rhs_storage._setCandidateOn {return false}
        if _storage._setCandidateOff != rhs_storage._setCandidateOff {return false}
        if _storage._createMultisig != rhs_storage._createMultisig {return false}
        if _storage._multisendBase != rhs_storage._multisendBase {return false}
        if _storage._multisendDelta != rhs_storage._multisendDelta {return false}
        if _storage._editCandidate != rhs_storage._editCandidate {return false}
        if _storage._setHaltBlock != rhs_storage._setHaltBlock {return false}
        if _storage._editTickerOwner != rhs_storage._editTickerOwner {return false}
        if _storage._editMultisig != rhs_storage._editMultisig {return false}
        if _storage._editCandidatePublicKey != rhs_storage._editCandidatePublicKey {return false}
        if _storage._createSwapPool != rhs_storage._createSwapPool {return false}
        if _storage._addLiquidity != rhs_storage._addLiquidity {return false}
        if _storage._removeLiquidity != rhs_storage._removeLiquidity {return false}
        if _storage._editCandidateCommission != rhs_storage._editCandidateCommission {return false}
        if _storage._mintToken != rhs_storage._mintToken {return false}
        if _storage._burnToken != rhs_storage._burnToken {return false}
        if _storage._voteCommission != rhs_storage._voteCommission {return false}
        if _storage._voteUpdate != rhs_storage._voteUpdate {return false}
        if _storage._failedTx != rhs_storage._failedTx {return false}
        if _storage._addLimitOrder != rhs_storage._addLimitOrder {return false}
        if _storage._removeLimitOrder != rhs_storage._removeLimitOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterVoteUpdateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoteUpdateData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "height"),
    3: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterVoteUpdateData, rhs: MinterVoteUpdateData) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.height != rhs.height {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterAddLimitOrderData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddLimitOrderData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_to_sell"),
    2: .standard(proto: "value_to_sell"),
    3: .standard(proto: "coin_to_buy"),
    4: .standard(proto: "value_to_buy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coinToSell) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.valueToSell) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._coinToBuy) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.valueToBuy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coinToSell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.valueToSell.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToSell, fieldNumber: 2)
    }
    try { if let v = self._coinToBuy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.valueToBuy.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToBuy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterAddLimitOrderData, rhs: MinterAddLimitOrderData) -> Bool {
    if lhs._coinToSell != rhs._coinToSell {return false}
    if lhs.valueToSell != rhs.valueToSell {return false}
    if lhs._coinToBuy != rhs._coinToBuy {return false}
    if lhs.valueToBuy != rhs.valueToBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRemoveLimitOrderData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveLimitOrderData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterRemoveLimitOrderData, rhs: MinterRemoveLimitOrderData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
