// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct MinterJailEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validatorPubKey: String = String()

  public var jailedUntil: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterRemoveCandidateEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var candidatePubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterRewardEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: MinterRewardEvent.Role = .validator

  public var address: String = String()

  public var amount: String = String()

  public var coin: UInt64 = 0

  public var validatorPubKey: String = String()

  /// coin for which the delegator received the reward
  public var forCoin: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Role: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case validator // = 0
    case delegator // = 1
    case dao // = 2
    case developers // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .validator
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .validator
      case 1: self = .delegator
      case 2: self = .dao
      case 3: self = .developers
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .validator: return 0
      case .delegator: return 1
      case .dao: return 2
      case .developers: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension MinterRewardEvent.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MinterRewardEvent.Role] = [
    .validator,
    .delegator,
    .dao,
    .developers,
  ]
}

#endif  // swift(>=4.2)

public struct MinterSlashEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var amount: String = String()

  public var coin: UInt64 = 0

  public var validatorPubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterUnbondEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var amount: String = String()

  public var coin: UInt64 = 0

  public var validatorPubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterStakeKickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var amount: String = String()

  public var coin: UInt64 = 0

  public var validatorPubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterUpdateNetworkEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MinterUpdateCommissionsEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: UInt64 {
    get {return _storage._coin}
    set {_uniqueStorage()._coin = newValue}
  }

  public var payloadByte: String {
    get {return _storage._payloadByte}
    set {_uniqueStorage()._payloadByte = newValue}
  }

  public var send: String {
    get {return _storage._send}
    set {_uniqueStorage()._send = newValue}
  }

  public var buyBancor: String {
    get {return _storage._buyBancor}
    set {_uniqueStorage()._buyBancor = newValue}
  }

  public var sellBancor: String {
    get {return _storage._sellBancor}
    set {_uniqueStorage()._sellBancor = newValue}
  }

  public var sellAllBancor: String {
    get {return _storage._sellAllBancor}
    set {_uniqueStorage()._sellAllBancor = newValue}
  }

  public var buyPoolBase: String {
    get {return _storage._buyPoolBase}
    set {_uniqueStorage()._buyPoolBase = newValue}
  }

  public var buyPoolDelta: String {
    get {return _storage._buyPoolDelta}
    set {_uniqueStorage()._buyPoolDelta = newValue}
  }

  public var sellPoolBase: String {
    get {return _storage._sellPoolBase}
    set {_uniqueStorage()._sellPoolBase = newValue}
  }

  public var sellPoolDelta: String {
    get {return _storage._sellPoolDelta}
    set {_uniqueStorage()._sellPoolDelta = newValue}
  }

  public var sellAllPoolBase: String {
    get {return _storage._sellAllPoolBase}
    set {_uniqueStorage()._sellAllPoolBase = newValue}
  }

  public var sellAllPoolDelta: String {
    get {return _storage._sellAllPoolDelta}
    set {_uniqueStorage()._sellAllPoolDelta = newValue}
  }

  public var createTicker3: String {
    get {return _storage._createTicker3}
    set {_uniqueStorage()._createTicker3 = newValue}
  }

  public var createTicker4: String {
    get {return _storage._createTicker4}
    set {_uniqueStorage()._createTicker4 = newValue}
  }

  public var createTicker5: String {
    get {return _storage._createTicker5}
    set {_uniqueStorage()._createTicker5 = newValue}
  }

  public var createTicker6: String {
    get {return _storage._createTicker6}
    set {_uniqueStorage()._createTicker6 = newValue}
  }

  public var createTicker710: String {
    get {return _storage._createTicker710}
    set {_uniqueStorage()._createTicker710 = newValue}
  }

  public var createCoin: String {
    get {return _storage._createCoin}
    set {_uniqueStorage()._createCoin = newValue}
  }

  public var createToken: String {
    get {return _storage._createToken}
    set {_uniqueStorage()._createToken = newValue}
  }

  public var recreateCoin: String {
    get {return _storage._recreateCoin}
    set {_uniqueStorage()._recreateCoin = newValue}
  }

  public var recreateToken: String {
    get {return _storage._recreateToken}
    set {_uniqueStorage()._recreateToken = newValue}
  }

  public var declareCandidacy: String {
    get {return _storage._declareCandidacy}
    set {_uniqueStorage()._declareCandidacy = newValue}
  }

  public var delegate: String {
    get {return _storage._delegate}
    set {_uniqueStorage()._delegate = newValue}
  }

  public var unbond: String {
    get {return _storage._unbond}
    set {_uniqueStorage()._unbond = newValue}
  }

  public var redeemCheck: String {
    get {return _storage._redeemCheck}
    set {_uniqueStorage()._redeemCheck = newValue}
  }

  public var setCandidateOn: String {
    get {return _storage._setCandidateOn}
    set {_uniqueStorage()._setCandidateOn = newValue}
  }

  public var setCandidateOff: String {
    get {return _storage._setCandidateOff}
    set {_uniqueStorage()._setCandidateOff = newValue}
  }

  public var createMultisig: String {
    get {return _storage._createMultisig}
    set {_uniqueStorage()._createMultisig = newValue}
  }

  public var multisendBase: String {
    get {return _storage._multisendBase}
    set {_uniqueStorage()._multisendBase = newValue}
  }

  public var multisendDelta: String {
    get {return _storage._multisendDelta}
    set {_uniqueStorage()._multisendDelta = newValue}
  }

  public var editCandidate: String {
    get {return _storage._editCandidate}
    set {_uniqueStorage()._editCandidate = newValue}
  }

  public var setHaltBlock: String {
    get {return _storage._setHaltBlock}
    set {_uniqueStorage()._setHaltBlock = newValue}
  }

  public var editTickerOwner: String {
    get {return _storage._editTickerOwner}
    set {_uniqueStorage()._editTickerOwner = newValue}
  }

  public var editMultisig: String {
    get {return _storage._editMultisig}
    set {_uniqueStorage()._editMultisig = newValue}
  }

  public var editCandidatePublicKey: String {
    get {return _storage._editCandidatePublicKey}
    set {_uniqueStorage()._editCandidatePublicKey = newValue}
  }

  public var createSwapPool: String {
    get {return _storage._createSwapPool}
    set {_uniqueStorage()._createSwapPool = newValue}
  }

  public var addLiquidity: String {
    get {return _storage._addLiquidity}
    set {_uniqueStorage()._addLiquidity = newValue}
  }

  public var removeLiquidity: String {
    get {return _storage._removeLiquidity}
    set {_uniqueStorage()._removeLiquidity = newValue}
  }

  public var editCandidateCommission: String {
    get {return _storage._editCandidateCommission}
    set {_uniqueStorage()._editCandidateCommission = newValue}
  }

  public var mintToken: String {
    get {return _storage._mintToken}
    set {_uniqueStorage()._mintToken = newValue}
  }

  public var burnToken: String {
    get {return _storage._burnToken}
    set {_uniqueStorage()._burnToken = newValue}
  }

  public var voteCommission: String {
    get {return _storage._voteCommission}
    set {_uniqueStorage()._voteCommission = newValue}
  }

  public var voteUpdate: String {
    get {return _storage._voteUpdate}
    set {_uniqueStorage()._voteUpdate = newValue}
  }

  public var failedTx: String {
    get {return _storage._failedTx}
    set {_uniqueStorage()._failedTx = newValue}
  }

  public var addLimitOrder: String {
    get {return _storage._addLimitOrder}
    set {_uniqueStorage()._addLimitOrder = newValue}
  }

  public var removeLimitOrder: String {
    get {return _storage._removeLimitOrder}
    set {_uniqueStorage()._removeLimitOrder = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MinterOrderExpiredEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var address: String = String()

  public var coin: UInt64 = 0

  public var amount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api_pb"

extension MinterJailEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JailEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_pub_key"),
    2: .standard(proto: "jailed_until"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorPubKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.jailedUntil) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorPubKey, fieldNumber: 1)
    }
    if self.jailedUntil != 0 {
      try visitor.visitSingularUInt64Field(value: self.jailedUntil, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterJailEvent, rhs: MinterJailEvent) -> Bool {
    if lhs.validatorPubKey != rhs.validatorPubKey {return false}
    if lhs.jailedUntil != rhs.jailedUntil {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRemoveCandidateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveCandidateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "candidate_pub_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.candidatePubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candidatePubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.candidatePubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterRemoveCandidateEvent, rhs: MinterRemoveCandidateEvent) -> Bool {
    if lhs.candidatePubKey != rhs.candidatePubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRewardEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RewardEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "address"),
    3: .same(proto: "amount"),
    5: .same(proto: "coin"),
    4: .standard(proto: "validator_pub_key"),
    6: .standard(proto: "for_coin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.validatorPubKey) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.forCoin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.role != .validator {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 3)
    }
    if !self.validatorPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorPubKey, fieldNumber: 4)
    }
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 5)
    }
    if self.forCoin != 0 {
      try visitor.visitSingularUInt64Field(value: self.forCoin, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterRewardEvent, rhs: MinterRewardEvent) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.validatorPubKey != rhs.validatorPubKey {return false}
    if lhs.forCoin != rhs.forCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterRewardEvent.Role: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Validator"),
    1: .same(proto: "Delegator"),
    2: .same(proto: "DAO"),
    3: .same(proto: "Developers"),
  ]
}

extension MinterSlashEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SlashEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "amount"),
    3: .same(proto: "coin"),
    4: .standard(proto: "validator_pub_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.validatorPubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 3)
    }
    if !self.validatorPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorPubKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterSlashEvent, rhs: MinterSlashEvent) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.validatorPubKey != rhs.validatorPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUnbondEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnbondEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "amount"),
    3: .same(proto: "coin"),
    4: .standard(proto: "validator_pub_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.validatorPubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 3)
    }
    if !self.validatorPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorPubKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUnbondEvent, rhs: MinterUnbondEvent) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.validatorPubKey != rhs.validatorPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterStakeKickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeKickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "amount"),
    3: .same(proto: "coin"),
    4: .standard(proto: "validator_pub_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.validatorPubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 3)
    }
    if !self.validatorPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorPubKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterStakeKickEvent, rhs: MinterStakeKickEvent) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.validatorPubKey != rhs.validatorPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUpdateNetworkEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNetworkEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUpdateNetworkEvent, rhs: MinterUpdateNetworkEvent) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterUpdateCommissionsEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCommissionsEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "coin"),
    4: .standard(proto: "payload_byte"),
    5: .same(proto: "send"),
    38: .standard(proto: "buy_bancor"),
    39: .standard(proto: "sell_bancor"),
    40: .standard(proto: "sell_all_bancor"),
    41: .standard(proto: "buy_pool_base"),
    53: .standard(proto: "buy_pool_delta"),
    42: .standard(proto: "sell_pool_base"),
    54: .standard(proto: "sell_pool_delta"),
    43: .standard(proto: "sell_all_pool_base"),
    55: .standard(proto: "sell_all_pool_delta"),
    7: .standard(proto: "create_ticker3"),
    8: .standard(proto: "create_ticker4"),
    9: .standard(proto: "create_ticker5"),
    10: .standard(proto: "create_ticker6"),
    11: .standard(proto: "create_ticker7_10"),
    34: .standard(proto: "create_coin"),
    35: .standard(proto: "create_token"),
    36: .standard(proto: "recreate_coin"),
    37: .standard(proto: "recreate_token"),
    13: .standard(proto: "declare_candidacy"),
    14: .same(proto: "delegate"),
    15: .same(proto: "unbond"),
    16: .standard(proto: "redeem_check"),
    44: .standard(proto: "set_candidate_on"),
    45: .standard(proto: "set_candidate_off"),
    18: .standard(proto: "create_multisig"),
    51: .standard(proto: "multisend_base"),
    52: .standard(proto: "multisend_delta"),
    20: .standard(proto: "edit_candidate"),
    21: .standard(proto: "set_halt_block"),
    22: .standard(proto: "edit_ticker_owner"),
    23: .standard(proto: "edit_multisig"),
    25: .standard(proto: "edit_candidate_public_key"),
    48: .standard(proto: "create_swap_pool"),
    49: .standard(proto: "add_liquidity"),
    50: .standard(proto: "remove_liquidity"),
    28: .standard(proto: "edit_candidate_commission"),
    46: .standard(proto: "mint_token"),
    47: .standard(proto: "burn_token"),
    31: .standard(proto: "vote_commission"),
    32: .standard(proto: "vote_update"),
    56: .standard(proto: "failed_tx"),
    57: .standard(proto: "add_limit_order"),
    58: .standard(proto: "remove_limit_order"),
  ]

  fileprivate class _StorageClass {
    var _coin: UInt64 = 0
    var _payloadByte: String = String()
    var _send: String = String()
    var _buyBancor: String = String()
    var _sellBancor: String = String()
    var _sellAllBancor: String = String()
    var _buyPoolBase: String = String()
    var _buyPoolDelta: String = String()
    var _sellPoolBase: String = String()
    var _sellPoolDelta: String = String()
    var _sellAllPoolBase: String = String()
    var _sellAllPoolDelta: String = String()
    var _createTicker3: String = String()
    var _createTicker4: String = String()
    var _createTicker5: String = String()
    var _createTicker6: String = String()
    var _createTicker710: String = String()
    var _createCoin: String = String()
    var _createToken: String = String()
    var _recreateCoin: String = String()
    var _recreateToken: String = String()
    var _declareCandidacy: String = String()
    var _delegate: String = String()
    var _unbond: String = String()
    var _redeemCheck: String = String()
    var _setCandidateOn: String = String()
    var _setCandidateOff: String = String()
    var _createMultisig: String = String()
    var _multisendBase: String = String()
    var _multisendDelta: String = String()
    var _editCandidate: String = String()
    var _setHaltBlock: String = String()
    var _editTickerOwner: String = String()
    var _editMultisig: String = String()
    var _editCandidatePublicKey: String = String()
    var _createSwapPool: String = String()
    var _addLiquidity: String = String()
    var _removeLiquidity: String = String()
    var _editCandidateCommission: String = String()
    var _mintToken: String = String()
    var _burnToken: String = String()
    var _voteCommission: String = String()
    var _voteUpdate: String = String()
    var _failedTx: String = String()
    var _addLimitOrder: String = String()
    var _removeLimitOrder: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coin = source._coin
      _payloadByte = source._payloadByte
      _send = source._send
      _buyBancor = source._buyBancor
      _sellBancor = source._sellBancor
      _sellAllBancor = source._sellAllBancor
      _buyPoolBase = source._buyPoolBase
      _buyPoolDelta = source._buyPoolDelta
      _sellPoolBase = source._sellPoolBase
      _sellPoolDelta = source._sellPoolDelta
      _sellAllPoolBase = source._sellAllPoolBase
      _sellAllPoolDelta = source._sellAllPoolDelta
      _createTicker3 = source._createTicker3
      _createTicker4 = source._createTicker4
      _createTicker5 = source._createTicker5
      _createTicker6 = source._createTicker6
      _createTicker710 = source._createTicker710
      _createCoin = source._createCoin
      _createToken = source._createToken
      _recreateCoin = source._recreateCoin
      _recreateToken = source._recreateToken
      _declareCandidacy = source._declareCandidacy
      _delegate = source._delegate
      _unbond = source._unbond
      _redeemCheck = source._redeemCheck
      _setCandidateOn = source._setCandidateOn
      _setCandidateOff = source._setCandidateOff
      _createMultisig = source._createMultisig
      _multisendBase = source._multisendBase
      _multisendDelta = source._multisendDelta
      _editCandidate = source._editCandidate
      _setHaltBlock = source._setHaltBlock
      _editTickerOwner = source._editTickerOwner
      _editMultisig = source._editMultisig
      _editCandidatePublicKey = source._editCandidatePublicKey
      _createSwapPool = source._createSwapPool
      _addLiquidity = source._addLiquidity
      _removeLiquidity = source._removeLiquidity
      _editCandidateCommission = source._editCandidateCommission
      _mintToken = source._mintToken
      _burnToken = source._burnToken
      _voteCommission = source._voteCommission
      _voteUpdate = source._voteUpdate
      _failedTx = source._failedTx
      _addLimitOrder = source._addLimitOrder
      _removeLimitOrder = source._removeLimitOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._coin) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._payloadByte) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._send) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._createTicker3) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._createTicker4) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._createTicker5) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._createTicker6) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._createTicker710) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._declareCandidacy) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._delegate) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._unbond) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._redeemCheck) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._createMultisig) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._editCandidate) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._setHaltBlock) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._editTickerOwner) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._editMultisig) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._editCandidatePublicKey) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._editCandidateCommission) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._voteCommission) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._voteUpdate) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._createCoin) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._createToken) }()
        case 36: try { try decoder.decodeSingularStringField(value: &_storage._recreateCoin) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._recreateToken) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._buyBancor) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._sellBancor) }()
        case 40: try { try decoder.decodeSingularStringField(value: &_storage._sellAllBancor) }()
        case 41: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolBase) }()
        case 42: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolBase) }()
        case 43: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolBase) }()
        case 44: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOn) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._setCandidateOff) }()
        case 46: try { try decoder.decodeSingularStringField(value: &_storage._mintToken) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._burnToken) }()
        case 48: try { try decoder.decodeSingularStringField(value: &_storage._createSwapPool) }()
        case 49: try { try decoder.decodeSingularStringField(value: &_storage._addLiquidity) }()
        case 50: try { try decoder.decodeSingularStringField(value: &_storage._removeLiquidity) }()
        case 51: try { try decoder.decodeSingularStringField(value: &_storage._multisendBase) }()
        case 52: try { try decoder.decodeSingularStringField(value: &_storage._multisendDelta) }()
        case 53: try { try decoder.decodeSingularStringField(value: &_storage._buyPoolDelta) }()
        case 54: try { try decoder.decodeSingularStringField(value: &_storage._sellPoolDelta) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._sellAllPoolDelta) }()
        case 56: try { try decoder.decodeSingularStringField(value: &_storage._failedTx) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._addLimitOrder) }()
        case 58: try { try decoder.decodeSingularStringField(value: &_storage._removeLimitOrder) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._coin != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._coin, fieldNumber: 3)
      }
      if !_storage._payloadByte.isEmpty {
        try visitor.visitSingularStringField(value: _storage._payloadByte, fieldNumber: 4)
      }
      if !_storage._send.isEmpty {
        try visitor.visitSingularStringField(value: _storage._send, fieldNumber: 5)
      }
      if !_storage._createTicker3.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker3, fieldNumber: 7)
      }
      if !_storage._createTicker4.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker4, fieldNumber: 8)
      }
      if !_storage._createTicker5.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker5, fieldNumber: 9)
      }
      if !_storage._createTicker6.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker6, fieldNumber: 10)
      }
      if !_storage._createTicker710.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTicker710, fieldNumber: 11)
      }
      if !_storage._declareCandidacy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._declareCandidacy, fieldNumber: 13)
      }
      if !_storage._delegate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegate, fieldNumber: 14)
      }
      if !_storage._unbond.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unbond, fieldNumber: 15)
      }
      if !_storage._redeemCheck.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redeemCheck, fieldNumber: 16)
      }
      if !_storage._createMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createMultisig, fieldNumber: 18)
      }
      if !_storage._editCandidate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidate, fieldNumber: 20)
      }
      if !_storage._setHaltBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setHaltBlock, fieldNumber: 21)
      }
      if !_storage._editTickerOwner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editTickerOwner, fieldNumber: 22)
      }
      if !_storage._editMultisig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editMultisig, fieldNumber: 23)
      }
      if !_storage._editCandidatePublicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidatePublicKey, fieldNumber: 25)
      }
      if !_storage._editCandidateCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editCandidateCommission, fieldNumber: 28)
      }
      if !_storage._voteCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteCommission, fieldNumber: 31)
      }
      if !_storage._voteUpdate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voteUpdate, fieldNumber: 32)
      }
      if !_storage._createCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createCoin, fieldNumber: 34)
      }
      if !_storage._createToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createToken, fieldNumber: 35)
      }
      if !_storage._recreateCoin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateCoin, fieldNumber: 36)
      }
      if !_storage._recreateToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recreateToken, fieldNumber: 37)
      }
      if !_storage._buyBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyBancor, fieldNumber: 38)
      }
      if !_storage._sellBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellBancor, fieldNumber: 39)
      }
      if !_storage._sellAllBancor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllBancor, fieldNumber: 40)
      }
      if !_storage._buyPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolBase, fieldNumber: 41)
      }
      if !_storage._sellPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolBase, fieldNumber: 42)
      }
      if !_storage._sellAllPoolBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolBase, fieldNumber: 43)
      }
      if !_storage._setCandidateOn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOn, fieldNumber: 44)
      }
      if !_storage._setCandidateOff.isEmpty {
        try visitor.visitSingularStringField(value: _storage._setCandidateOff, fieldNumber: 45)
      }
      if !_storage._mintToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mintToken, fieldNumber: 46)
      }
      if !_storage._burnToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._burnToken, fieldNumber: 47)
      }
      if !_storage._createSwapPool.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createSwapPool, fieldNumber: 48)
      }
      if !_storage._addLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLiquidity, fieldNumber: 49)
      }
      if !_storage._removeLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLiquidity, fieldNumber: 50)
      }
      if !_storage._multisendBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendBase, fieldNumber: 51)
      }
      if !_storage._multisendDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._multisendDelta, fieldNumber: 52)
      }
      if !_storage._buyPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buyPoolDelta, fieldNumber: 53)
      }
      if !_storage._sellPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellPoolDelta, fieldNumber: 54)
      }
      if !_storage._sellAllPoolDelta.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sellAllPoolDelta, fieldNumber: 55)
      }
      if !_storage._failedTx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._failedTx, fieldNumber: 56)
      }
      if !_storage._addLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addLimitOrder, fieldNumber: 57)
      }
      if !_storage._removeLimitOrder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._removeLimitOrder, fieldNumber: 58)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterUpdateCommissionsEvent, rhs: MinterUpdateCommissionsEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coin != rhs_storage._coin {return false}
        if _storage._payloadByte != rhs_storage._payloadByte {return false}
        if _storage._send != rhs_storage._send {return false}
        if _storage._buyBancor != rhs_storage._buyBancor {return false}
        if _storage._sellBancor != rhs_storage._sellBancor {return false}
        if _storage._sellAllBancor != rhs_storage._sellAllBancor {return false}
        if _storage._buyPoolBase != rhs_storage._buyPoolBase {return false}
        if _storage._buyPoolDelta != rhs_storage._buyPoolDelta {return false}
        if _storage._sellPoolBase != rhs_storage._sellPoolBase {return false}
        if _storage._sellPoolDelta != rhs_storage._sellPoolDelta {return false}
        if _storage._sellAllPoolBase != rhs_storage._sellAllPoolBase {return false}
        if _storage._sellAllPoolDelta != rhs_storage._sellAllPoolDelta {return false}
        if _storage._createTicker3 != rhs_storage._createTicker3 {return false}
        if _storage._createTicker4 != rhs_storage._createTicker4 {return false}
        if _storage._createTicker5 != rhs_storage._createTicker5 {return false}
        if _storage._createTicker6 != rhs_storage._createTicker6 {return false}
        if _storage._createTicker710 != rhs_storage._createTicker710 {return false}
        if _storage._createCoin != rhs_storage._createCoin {return false}
        if _storage._createToken != rhs_storage._createToken {return false}
        if _storage._recreateCoin != rhs_storage._recreateCoin {return false}
        if _storage._recreateToken != rhs_storage._recreateToken {return false}
        if _storage._declareCandidacy != rhs_storage._declareCandidacy {return false}
        if _storage._delegate != rhs_storage._delegate {return false}
        if _storage._unbond != rhs_storage._unbond {return false}
        if _storage._redeemCheck != rhs_storage._redeemCheck {return false}
        if _storage._setCandidateOn != rhs_storage._setCandidateOn {return false}
        if _storage._setCandidateOff != rhs_storage._setCandidateOff {return false}
        if _storage._createMultisig != rhs_storage._createMultisig {return false}
        if _storage._multisendBase != rhs_storage._multisendBase {return false}
        if _storage._multisendDelta != rhs_storage._multisendDelta {return false}
        if _storage._editCandidate != rhs_storage._editCandidate {return false}
        if _storage._setHaltBlock != rhs_storage._setHaltBlock {return false}
        if _storage._editTickerOwner != rhs_storage._editTickerOwner {return false}
        if _storage._editMultisig != rhs_storage._editMultisig {return false}
        if _storage._editCandidatePublicKey != rhs_storage._editCandidatePublicKey {return false}
        if _storage._createSwapPool != rhs_storage._createSwapPool {return false}
        if _storage._addLiquidity != rhs_storage._addLiquidity {return false}
        if _storage._removeLiquidity != rhs_storage._removeLiquidity {return false}
        if _storage._editCandidateCommission != rhs_storage._editCandidateCommission {return false}
        if _storage._mintToken != rhs_storage._mintToken {return false}
        if _storage._burnToken != rhs_storage._burnToken {return false}
        if _storage._voteCommission != rhs_storage._voteCommission {return false}
        if _storage._voteUpdate != rhs_storage._voteUpdate {return false}
        if _storage._failedTx != rhs_storage._failedTx {return false}
        if _storage._addLimitOrder != rhs_storage._addLimitOrder {return false}
        if _storage._removeLimitOrder != rhs_storage._removeLimitOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinterOrderExpiredEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderExpiredEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "address"),
    3: .same(proto: "coin"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.coin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if self.coin != 0 {
      try visitor.visitSingularUInt64Field(value: self.coin, fieldNumber: 3)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinterOrderExpiredEvent, rhs: MinterOrderExpiredEvent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.address != rhs.address {return false}
    if lhs.coin != rhs.coin {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
